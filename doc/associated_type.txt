> in rust, ho il seguente problema: vorrei associare ad un tipo dato che ho (una enum, che enumera dei tipi di
  comando, tipo "Answer", "Include", "Derive") un tipo di Stato associato (opzionale se possibile, tipo "Include"
   non ha stato; se impossibile, va bene uno stato "null" inutile); vorrei delle unzioni tipo
  "crea_stato(tipo_di_comando) => nuovo stato del tipo Stato associato); poi vorrei anche dispatch dei metodi.
  Somiglia abbastanza ad un trait quello che voglio; orse la soluzione e' poter associare una istanza di un trait
   (che puo' contenere tipi associari da quel che so) ad un tipo della mia enum dei comandi. Esempio?
  Alternative? Impossibilita'?

✦ Certamente. La tua intuizione è corretta: i trait sono la soluzione più idiomatica e potente in Rust per
  questo tipo di problema. L'idea è usare una combinazione di enum, struct e trait.

  Non si "associa un'istanza di un trait" a una variante di un'enum, ma si può fare in modo che ogni variante
  dell'enum contenga un tipo (struct) che a sua volta implementa un trait comune. Questo ti dà sia lo stato
  specifico per ogni comando, sia un'interfaccia comune per il dispatch dei metodi.

  Ti mostro due approcci principali, con i relativi vantaggi e svantaggi.

  Soluzione 1: Enum come "Contenitore di Stato" (Approccio Consigliato)

  Questo è l'approccio più comune e sicuro in Rust. L'idea è avere:
   1. Un'enum per i tipi di comando (CommandType).
   2. Delle struct per rappresentare lo stato di ogni comando.
   3. Un trait per definire il comportamento comune.
   4. Un'enum "contenitore" che racchiude lo stato specifico di ogni comando.

  Vediamo il codice.

  Soluzione 1: Enum come "Contenitore di Stato" (Approccio Consigliato)

  Questo è l'approccio più comune e sicuro in Rust. L'idea è avere:
   1. Un'enum per i tipi di comando (CommandType).
   2. Delle struct per rappresentare lo stato di ogni comando.
   3. Un trait per definire il comportamento comune.
   4. Un'enum "contenitore" che racchiude lo stato specifico di ogni comando e gestisce il dispatch.

     1 // 1. L'enum che definisce i TIPI di comando
     2 #[derive(Debug, Clone, Copy)]
     3 pub enum CommandType {
     4     Answer,
     5     Include,
     6     Derive,
     7 }
     8
     9 // 2. Le struct che definiscono lo STATO per ogni tipo di comando
    10 #[derive(Debug, Default)]
    11 pub struct AnswerState {
    12     pub answers_count: u32,
    13 }
    14
    15 #[derive(Debug, Default)]
    16 pub struct DeriveState {
    17     pub derived_items: Vec<String>,
    18 }
    19
    20 // Per "Include", che non ha stato, non creiamo una struct dedicata.
    21
    22 // 3. Il trait che definisce il COMPORTAMENTO comune
    23 pub trait CommandBehavior {
    24     fn execute(&mut self);
    25     fn description(&self) -> String;
    26 }
    27
    28 // 4. Implementiamo il trait per ogni struct di stato
    29 impl CommandBehavior for AnswerState {
    30     fn execute(&mut self) {
    31         self.answers_count += 1;
    32         println!("Executing Answer command. Total answers: {}", self.answers_count);
    33     }
    34     fn description(&self) -> String {
    35         format!("Answer command state (count: {})", self.answers_count)
    36     }
    37 }
    38
    39 impl CommandBehavior for DeriveState {
    40     fn execute(&mut self) {
    41         let new_item = format!("item_{}", self.derived_items.len() + 1);
    42         self.derived_items.push(new_item.clone());
    43         println!("Executing Derive command. Added '{}'", new_item);
    44     }
    45     fn description(&self) -> String {
    46         format!("Derive command state (items: {:?})", self.derived_items)
    47     }
    48 }
    49
    50 // 5. L'enum "contenitore" che lega tutto insieme.
    51 //    Ogni variante CONTIENE la struct di stato corrispondente.
    52 //    "Include" è una variante unitaria perché non ha stato.
    53 #[derive(Debug)]
    54 pub enum Command {
    55     Answer(AnswerState),
    56     Include, // Niente stato, niente struct
    57     Derive(DeriveState),
    58 }
    59
    60 impl Command {
    61     // 6. Funzione di "dispatch" che invoca il comportamento corretto
    62     pub fn execute(&mut self) {
    63         match self {
    64             Command::Answer(state) => state.execute(),
    65             Command::Derive(state) => state.execute(),
    66             Command::Include => println!("Executing Include command. No state to modify."),
    67         }
    68     }
    69
    70     pub fn description(&self) -> String {
    71         match self {
    72             Command::Answer(state) => state.description(),
    73             Command::Derive(state) => state.description(),
    74             Command::Include => "Include command (stateless)".to_string(),
    75         }
    76     }
    77 }
    78
    79 // 7. La funzione "factory" che crea il comando con il suo stato iniziale
    80 pub fn create_command_with_state(cmd_type: CommandType) -> Command {
    81     match cmd_type {
    82         CommandType::Answer => Command::Answer(AnswerState::default()),
    83         CommandType::Include => Command::Include,
    84         CommandType::Derive => Command::Derive(DeriveState::default()),
    85     }
    86 }
    87
    88 fn main() {
    89     // Creiamo i comandi
    90     let mut answer_cmd = create_command_with_state(CommandType::Answer);
    91     let include_cmd = create_command_with_state(CommandType::Include);
    92     let mut derive_cmd = create_command_with_state(CommandType::Derive);
    93
    94     println!("Initial state:");
    95     println!("- {}", answer_cmd.description());
    96     println!("- {}", include_cmd.description());
    97     println!("- {}", derive_cmd.description());
    98
    99     println!("\n--- Executing commands ---");
   100     answer_cmd.execute();
   101     include_cmd.execute();
   102     derive_cmd.execute();
   103     derive_cmd.execute();
   104
   105     println!("\nFinal state:");
   106     println!("- {}", answer_cmd.description());
   107     println!("- {}", derive_cmd.description());
   108 }

  Soluzione 2: Trait Objects (Dynamic Dispatch)

  Questa alternativa è utile quando non vuoi (o non puoi) definire un'enum che contenga tutti i possibili
  stati, ad esempio perché vuoi permettere a librerie esterne di definire nuovi comandi. Usa Box<dyn Trait>
  per gestire tipi diversi in modo uniforme.

  In questo caso, anche il comando senza stato ha bisogno di una struct "vuota" che implementi il trait.

    1 // Tipi di comando e struct di stato rimangono quasi invariati
    2 #[derive(Debug, Clone, Copy)]
    3 pub enum CommandType {
    4     Answer,
    5     Include,
    6     Derive,
    7 }
    8
    9 #[derive(Debug, Default)]
   10 pub struct AnswerState { pub answers_count: u32 }
   11
   12 #[derive(Debug, Default)]
   13 pub struct DeriveState { pub derived_items: Vec<String> }
   14
   15 // Creiamo una struct "null" per i comandi senza stato
   16 #[derive(Debug, Default)]
   17 pub struct NullState;
   18
   19 // Il trait definisce l'interfaccia comune
   20 pub trait CommandBehavior {
   21     fn execute(&mut self);
   22     // Aggiungiamo 'Any' per poter fare downcasting se necessario, buona pratica
   23     fn as_any(&self) -> &dyn std::any::Any;
   24 }
   25
   26 // Implementiamo il trait per TUTTE le struct
   27 impl CommandBehavior for AnswerState {
   28     fn execute(&mut self) {
   29         self.answers_count += 1;
   30         println!("(dynamic) Executing Answer. Count: {}", self.answers_count);
   31     }
   32     fn as_any(&self) -> &dyn std::any::Any { self }
   33 }
   34
   35 impl CommandBehavior for DeriveState {
   36     fn execute(&mut self) {
   37         let new_item = format!("item_{}", self.derived_items.len() + 1);
   38         self.derived_items.push(new_item.clone());
   39         println!("(dynamic) Executing Derive. Added '{}'", new_item);
   40     }
   41     fn as_any(&self) -> &dyn std::any::Any { self }
   42 }
   43
   44 impl CommandBehavior for NullState {
   45     fn execute(&mut self) {
   46         println!("(dynamic) Executing stateless command.");
   47     }
   48     fn as_any(&self) -> &dyn std::any::Any { self }
   49 }
   50
   51 // La factory ora restituisce un Trait Object
   52 // Box<dyn ...> indica un puntatore a un dato "qualsiasi" che implementa quel trait
   53 pub fn create_state_object(cmd_type: CommandType) -> Box<dyn CommandBehavior> {
   54     match cmd_type {
   55         CommandType::Answer => Box::new(AnswerState::default()),
   56         CommandType::Include => Box::new(NullState::default()),
   57         CommandType::Derive => Box::new(DeriveState::default()),
   58     }
   59 }
   60
   61 fn main() {
   62     // Ora lavoriamo con una collezione eterogenea di stati
   63     let mut commands: Vec<Box<dyn CommandBehavior>> = vec![
   64         create_state_object(CommandType::Answer),
   65         create_state_object(CommandType::Include),
   66         create_state_object(CommandType::Derive),
   67     ];
   68
   69     for cmd in &mut commands {
   70         cmd.execute();
   71     }
   72
   73     println!("\n--- Esecuzione aggiuntiva ---");
   74     // Eseguiamo di nuovo solo il primo comando
   75     commands[0].execute();
   76
   77     // Se avessimo bisogno di recuperare lo stato concreto (raro)
   78     if let Some(answer_state) = commands[0].as_any().downcast_ref::<AnswerState>() {
   79         println!("\nRecuperato stato concreto: {} risposte.", answer_state.answers_count);
   80     }
   81 }

  Pro e Contro

  Soluzione 1 (Enum Contenitore)

   * Pro:
       * Performance: Utilizza lo static dispatch. Il compilatore sa a tempo di compilazione quale codice
         eseguire, senza bisogno di lookup a runtime. È più veloce.
       * Sicurezza: Il compilatore garantisce che tutti i casi possibili siano gestiti nel match.
       * Memoria: I dati sono allocati sullo stack (a meno che le struct stesse non contengano dati heap come
         Vec o String), evitando l'overhead di Box.
       * Chiarezza: L'enum Command definisce esplicitamente l'intero set di comandi possibili.

   * Contro:
       * Meno flessibile: Se vuoi aggiungere un nuovo tipo di comando, devi modificare la definizione dell'enum
         Command e tutti i match che la usano. Non è estensibile da codice esterno.

  Soluzione 2 (Trait Objects)

   * Pro:
       * Flessibilità: Puoi aggiungere nuovi tipi che implementano CommandBehavior senza modificare il codice
         esistente. Ottimo per architetture a plugin.
       * Collezioni Eterogenee: È la soluzione perfetta per mettere stati di tipo diverso nello stesso Vec, come
          mostrato nell'esempio.

   * Contro:
       * Performance: Utilizza il dynamic dispatch (tramite vtable), che ha un piccolo costo a runtime.
       * Complessità: Richiede l'allocazione sulla heap (Box), che introduce un altro livello di indirezione e
         gestione della memoria.
       * Meno informazioni a compile-time: Il compilatore sa solo che hai un Box<dyn CommandBehavior>, non quale
          tipo concreto si nasconde dietro.

  Conclusione

  Per la maggior parte dei casi d'uso, specialmente all'interno di una singola applicazione dove conosci tutti
   i tipi di comando, la Soluzione 1 è superiore. È più performante, più sicura e più idiomatica in Rust.

  Scegli la Soluzione 2 solo se hai un requisito specifico per la flessibilità, come la necessità di creare
  collezioni di comandi eterogenei o di permettere a terze parti di estendere il sistema.