Piano di Refactoring per `tool-format-tester` - Aderenza a Policy di Output Strutturato

**Obiettivo:** Evolvere il binario per valutare la conformità di un modello a una policy di output strutturato, che deve distinguere tra blocchi di tipo `TEXT`, `THOUGHT`, e `TOOL_CALL`.

**Concetto Chiave:** Il trait `ToolCallPolicy` verrà esteso per rappresentare una policy di parsing di output più generica. L'implementazione iniziale, `JsonToolCallPolicy`, sarà trasformata in `McpPolicy` per gestire un "Model Context Protocol" che parsifichi i tre tipi di blocco.

---

### Fase 1: Evoluzione delle Strutture Dati e del Trait

1.  **Modificare `policies.rs`:**
    -   Introdurre un nuovo enum `StructuredOutputBlock` per rappresentare i diversi tipi di contenuto che il modello può produrre. La struct `ParsedToolCall` esistente verrà usata all'interno di questo enum.
        ```rust
        #[derive(Debug, Serialize, Deserialize, Clone)]
        pub enum StructuredOutputBlock {
            Text(String),
            Thought(String),
            ToolCall(ParsedToolCall),
        }
        ```
    -   Aggiornare la firma del metodo `validate_and_parse` nel trait `ToolCallPolicy` per restituire un vettore di questi nuovi blocchi.
        ```rust
        // Vecchia firma: -> Result<Vec<ParsedToolCall>>
        // Nuova firma:
        fn validate_and_parse(&self, model_output: &str) -> Result<Vec<StructuredOutputBlock>>;
        ```

### Fase 2: Refactoring da `JsonToolCallPolicy` a `McpPolicy`

1.  **Rinominare e aggiornare la policy:**
    -   In `policies.rs`, rinominare `JsonToolCallPolicy` in `McpPolicy`.
    -   Il suo metodo `name()` restituirà `"mcp"`.

2.  **Implementare la nuova logica di parsing:**
    -   Riscrivere completamente il metodo `validate_and_parse` per `McpPolicy`.
    -   La nuova logica dovrà processare l'intero output del modello, non solo un singolo blocco JSON.
    -   Si userà un approccio basato su regex per identificare le righe che iniziano con `TEXT:`, `THOUGHT:`, o `TOOL_CALL:`.
    -   Per le righe `TOOL_CALL:`, il contenuto rimanente verrà parsato come JSON per creare una `ParsedToolCall`.
    -   Per `TEXT:` e `THOUGHT:`, il contenuto verrà salvato come semplice stringa.
    -   Il metodo costruirà e restituirà una `Vec<StructuredOutputBlock>` mantenendo l'ordine originale.

3.  **Aggiornare il prompt della policy:**
    -   Il metodo `build_prompt_section` di `McpPolicy` punterà a un nuovo file di template.

### Fase 3: Aggiornamento dell'Integrazione e dei Template

1.  **Modificare `cli_args.rs`:**
    -   Aggiornare l'argomento `--policy` per accettare `"mcp"` e impostarlo come valore predefinito.

2.  **Modificare `main.rs`:**
    -   Nel registro delle policy, sostituire `JsonToolCallPolicy` con `McpPolicy`.
    -   La funzione `save_test_result` è già sufficientemente generica e salverà correttamente la nuova struttura dati `Vec<StructuredOutputBlock>` senza bisogno di modifiche.

3.  **Aggiornare i template:**
    -   Rinominare `json_policy_prompt.hbs` in `mcp_policy_prompt.hbs`.
    -   Modificare il contenuto di `mcp_policy_prompt.hbs` per descrivere il nuovo protocollo che richiede al modello di etichettare ogni blocco di output con `TEXT:`, `THOUGHT:`, o `TOOL_CALL:`.
