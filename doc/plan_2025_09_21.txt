# Piano di Miglioramento per lo Script di Generazione Dati (`001_big_small_training_set_generation.py`)

## Obiettivo
Rendere lo script di generazione dati più robusto e flessibile, introducendo system prompt strutturati e normativi per il modello "small" (studente), con supporto per diversi formati di tool-calling (XML, JSON, MCP).

## Passi di Implementazione

### 1. Definizione Strutturata dei Tool
- **Azione:** All'interno dello script Python, definire una struttura dati (es. una lista di dizionari) che rappresenti i tool disponibili.
- **Dettagli:** Ogni tool sarà un oggetto con:
    - `name`: Nome del tool (es. `read_file`).
    - `description`: Breve spiegazione di cosa fa il tool.
    - `parameters`: Una lista di parametri, ognuno con `name`, `type`, e `description`.
- **Esempio (in Python):**
  ```python
  TOOLS_DEFINITION = [
      {
          "name": "read_file",
          "description": "Legge il contenuto di un file.",
          "parameters": [
              {"name": "absolute_path", "type": "string", "description": "Il percorso assoluto del file da leggere."}
          ]
      },
      # ... altri tool
  ]
  ```

### 2. Creazione dei Componenti del System Prompt
- **Azione:** Creare le due parti del system prompt come richiesto: la parte fissa (normativa) e la parte variabile (formato tool).
- **Parte Fissa (Normativa):**
    - Scrivere una stringa Python che contenga le regole generali per l'assistente.
    - **Contenuti:**
        - Deve ragionare (`THOUGHT`).
        - Deve usare i tool forniti quando necessario.
        - Deve usare **solo** i tool definiti.
        - Deve rispettare il formato di output specificato (JSON, XML, o MCP).
        - **Cruciale:** Deve fermarsi dopo aver emesso una chiamata a un tool (`TOOL_CODE`), senza simulare una risposta (`TOOL_RESPONSE`).
- **Parte Variabile (Formato Tool):**
    - Creare tre funzioni, una per ogni formato (`_build_xml_tool_spec`, `_build_json_tool_spec`, `_build_mcp_tool_spec`).
    - Ognuna di queste funzioni prenderà la `TOOLS_DEFINITION` (dal Passo 1) e genererà una stringa che descrive i tool nel formato richiesto.
    - **Esempio (XML):**
      ```xml
      <tools>
        <tool name="read_file" description="...">
          <parameter name="absolute_path" type="string" description="..." />
        </tool>
      </tools>
      ```

### 3. Integrazione nello Script
- **Azione:** Modificare la logica dello script per assemblare e usare i nuovi system prompt.
- **Aggiungere CLI Option:** Introdurre un nuovo argomento da riga di comando:
    - `--tool-format`: Permette di scegliere tra `xml`, `json`, `mcp`. Default a `mcp`.
- **Assemblaggio Dinamico:**
    - Prima di interrogare il modello "small", lo script costruirà il system prompt completo:
      1. Prende la parte fissa (normativa).
      2. In base al `--tool-format` scelto, chiama la funzione appropriata (es. `_build_xml_tool_spec`) per generare la specifica dei tool.
      3. Concatena le due parti per formare il system prompt finale.
- **Modifica Chiamata a `query_ollama`:**
    - La funzione `get_student_response` passerà il system prompt appena costruito alla funzione `query_ollama`.

### 4. Aggiornamento del Prompt di Etichettatura (Passo 3)
- **Azione:** Il prompt per il modello "big" (etichettatore) deve essere aggiornato.
- **Dettagli:** Quando si chiede al modello "big" di etichettare la risposta, ora gli forniremo anche il system prompt che è stato usato per il modello "small".
- **Nuovo Prompt di Etichettatura:**
  ```
  Sei un etichettatore...
  ...
  System Prompt Usato per l'Assistente:
  [Il system prompt completo usato al Passo 2]

  Prompt Utente:
  [Prompt generato al Passo 1]

  Risposta Assistente AI:
  [Risposta grezza del Modello Small al Passo 2]

  Output JSON:
  ```
- **Motivazione:** Fornire il system prompt completo dà al modello "big" il contesto necessario per capire perché la risposta dello "small" è formattata in un certo modo (XML, JSON, etc.), migliorando la qualità dell'etichettatura.

### 5. Test e Validazione
- **Azione:** Eseguire lo script aggiornato per ogni `--tool-format` e ispezionare manualmente i primi output generati.
- **Verifica:**
    - Il system prompt è assemblato correttamente?
    - La risposta del modello "small" rispetta (il più possibile) il formato richiesto?
    - L'etichettatura prodotta dal modello "big" è corretta e coerente con il formato?
