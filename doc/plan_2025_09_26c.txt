# Piano di Refactoring: Agenti e Memoria

**Data:** 26 Settembre 2025
**Basato su:** `doc/design_2025_09_26c.txt` (Revisione D)

## 1. Obiettivo del Piano

Questo piano delinea i passaggi per rifattorizzare il sistema di gestione degli Agenti per allinearlo al nuovo design. Gli obiettivi principali sono:
1.  Introdurre una distinzione forte e sicura tra agenti **AI** e **Umani**.
2.  Formalizzare il concetto di **Memory** come componente di prima classe per la gestione del contesto.
3.  Ristrutturare la persistenza degli agenti su filesystem per riflettere il nuovo modello dati.
4.  Definire e implementare le nuove API di `AgentLifecycle`.

---

## 2. Fasi del Refactoring

### Fase 0: Definizione delle Nuove Strutture Dati

**Obiettivo:** Introdurre tutte le nuove struct e enum necessarie, senza ancora implementare la logica complessa, per avere una base solida per la compilazione.

1.  **Crea `src/memory.rs`:**
    *   **Azione:** Creare un nuovo file `src/memory.rs`.
    *   **Contenuto:** Definire le struct ed enum dal design:
        *   `Message`
        *   `MessageContent` (con `Text`, `Thought`, `ToolResult`)
        *   `MessageStatus`
        *   `Memory` (con `root_path` e `messages`)
        *   Definire uno scheletro per i metodi di `Memory` (es. `load`, `new`, `add_message`) lasciandoli vuoti o con `unimplemented!()`.
    *   **Azione:** Aggiungere `pub mod memory;` in `src/lib.rs` e riesportare (`pub use memory::*;`).

2.  **Aggiorna `src/task.rs`:**
    *   **Azione:** Aggiungere il campo `pub assigned_agent_uid: Option<String>` alla struct `TaskStatus`.
    *   **Azione:** Aggiungere l'attributo `#[serde(default)]` al nuovo campo per garantire la retrocompatibilità con i file `status.json` esistenti.
    *   **Azione:** Aggiornare `Project::create_task` in `src/project.rs` per inizializzare `assigned_agent_uid: None` quando si crea un nuovo `TaskStatus`.

3.  **Riscrivi `src/agent.rs`:**
    *   **Azione:** Eliminare il contenuto attuale del file.
    *   **Azione:** Definire da zero le nuove struct ed enum come da design:
        *   `AgentMetadata`
        *   `AgentDetails` (enum con `AI(AIConfig)` e `Human(HumanConfig)`)
        *   `AIConfig`
        *   `LLMProviderConfig` (enum)
        *   `HumanConfig`
        *   `AgentState` (la versione semplificata con `last_seen_at` e `short_term_memory` rimosso)
        *   `Agent` (la nuova struct composita con `metadata`, `details`, `state`, e `memory`).

### Fase 1: Implementazione della Persistenza

**Obiettivo:** Modificare la creazione e il caricamento degli agenti per usare la nuova struttura a più file (`metadata.json`, `details.json`, `state.json`, `memory/`).

1.  **Riscrivi `Project::create_..._agent`:**
    *   **File:** `src/project.rs`
    *   **Azione:** Rimuovere la vecchia funzione `create_agent`.
    *   **Azione:** Implementare `pub fn create_ai_agent(&self, name: String, config: AIConfig) -> Result<Agent, ProjectError>`.
        *   Questa funzione dovrà:
            *   Generare un UID con prefisso `agt-`.
            *   Creare la directory `.vespe/agents/agt-xxxx/`.
            *   Creare la sottodirectory `memory/`.
            *   Creare e popolare `metadata.json`.
            *   Creare e popolare `details.json` con la variante `AgentDetails::AI`.
            *   Creare e popolare `state.json` con uno stato di default.
            *   Infine, chiamare `self.load_agent()` per restituire l'agente completo.
    *   **Azione:** Implementare `pub fn create_human_agent(&self, name: String, config: HumanConfig) -> Result<Agent, ProjectError>` (simile, ma con prefisso `usr-` e `AgentDetails::Human`).

2.  **Riscrivi `Project::load_agent`:**
    *   **File:** `src/project.rs`
    *   **Azione:** Modificare la funzione `load_agent` per:
        *   Leggere `metadata.json` nella struct `AgentMetadata`.
        *   Leggere `details.json` nella enum `AgentDetails`.
        *   Leggere `state.json` nella struct `AgentState`.
        *   Chiamare `Memory::load()` sulla directory `memory/` per inizializzare l'oggetto `Memory`.
        *   Assemblare e restituire la struct composita `Agent`.

3.  **Implementa `Memory::new` e `Memory::load`:**
    *   **File:** `src/memory.rs`
    *   **Azione:** Implementare la logica di `new` (crea la directory) e `load` (legge tutti i file `msg-*.json` dalla directory, li deserializza in `Message` e popola il vettore `self.messages`).

### Fase 2: Implementazione delle API di `Memory` e `AgentLifecycle`

**Obiettivo:** Dare vita alle nuove API definite nel design.

1.  **Implementa API di `Memory`:**
    *   **File:** `src/memory.rs`
    *   **Azione:** Implementare la logica per i metodi `add_message`, `delete_message`, `enable_message`, `disable_message`. Ogni metodo dovrà operare sia sulla cache in-memory (`self.messages`) sia sul file JSON corrispondente su disco.

2.  **Implementa `save_agent_state`:**
    *   **File:** `src/project.rs`
    *   **Azione:** Implementare `pub fn save_agent_state(&self, agent: &Agent) -> Result<(), ProjectError>` che serializza e scrive il campo `agent.state` nel file `state.json` corretto.

3.  **Implementa Assegnazione Task:**
    *   **File:** `src/project.rs`
    *   **Azione:** Implementare `assign_task_to_agent` e `unassign_agent_from_task`. Queste funzioni caricheranno il `Task` specificato, modificheranno il campo `assigned_agent_uid` in `TaskStatus` e salveranno il file `status.json` del task.

4.  **Implementa Comunicazione e `tick` (Scheletro):**
    *   **File:** `src/project.rs`
    *   **Azione:** Implementare `add_message_to_agent_memory`. Questa funzione caricherà l'agente, chiamerà il suo metodo `memory.add_message()`, e salverà il nuovo messaggio su disco.
    *   **Azione:** Creare uno scheletro per `tick_task`. Per ora, la funzione può caricare il task e l'agente assegnato e restituire un risultato fisso (es. `Ok(AgentTickResult::Waiting)`), rimandando l'implementazione della logica LLM.

### Fase 3: Pulizia e Adeguamento UI/CLI

**Obiettivo:** Allineare i client (CLI, TUI) al nuovo modello di agenti e pulire il codice obsoleto.

1.  **Aggiorna `vespe-cli`:**
    *   **Azione:** Modificare il comando `task create-agent` per supportare la creazione differenziata di agenti AI e Umani, con i relativi parametri di configurazione.
    *   **Azione:** Aggiornare i comandi `task show-agent` e `list-agents` per visualizzare le nuove informazioni.

2.  **Aggiorna `vespe-tui`:**
    *   **Azione:** Similmente alla CLI, aggiornare le viste per la creazione e visualizzazione degli agenti.

3.  **Verifica Finale:**
    *   **Azione:** Eseguire `cargo check --all` e `cargo test --all` per assicurarsi che l'intero workspace compili e funzioni correttamente.
    *   **Azione:** Scrivere nuovi test unitari per la logica di `Memory` e per la creazione/caricamento degli agenti.

Questo piano fornisce una roadmap dettagliata per il refactoring. Attendo la tua approvazione per procedere.