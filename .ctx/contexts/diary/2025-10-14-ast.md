@include rules
@include project
@include agent/planner

# 

vedi il nuovo modulo src/ast/mod.rs che dovrebbe sostituire syntax e semantic, e redigi un piano per la sua implementazione
SOLO implementazione del modulo, NON ancora integrazione.

<!-- answer-fdc92f60-a607-46ad-9e31-6ff2e48b6b85:begin -->
Here's a detailed plan for implementing the `src/ast/mod.rs` module, focusing solely on its internal implementation and not its integration with other parts of the project.

### Plan: Implement `src/ast/mod.rs`

1.  **Clean Up Existing `src/ast/mod.rs`:**
    *   **Objective:** Remove unused imports and resolve structural issues to prepare for new implementations.
    *   **Action:**
        *   Remove the `use sha2::digest::typenum::Double;` statement as it's currently unused and likely a leftover.
        *   Remove the duplicate `struct Text` definition.
        *   Correct the duplicate `parse_anchor` function definition. The function intended to parse arguments should be renamed to `parse_arguments` and its return type adjusted to `Result<Arguments, ParsingError>`.

2.  **Define `ParsingError`:**
    *   **Objective:** Create a robust error handling mechanism for parsing failures.
    *   **Action:** Implement a comprehensive `ParsingError` enum or struct. This should leverage `thiserror` for easy error definition and propagation, covering cases like unexpected tokens, invalid syntax, or premature end-of-file.

3.  **Implement `parse_parameters` Function:**
    *   **Objective:** Accurately parse JSON-formatted parameters.
    *   **Action:**
        *   Develop logic to detect and parse JSON objects enclosed in curly braces `{}`.
        *   Handle scenarios where parameters are optional (i.e., no `{}` is present), returning an empty JSON object in such cases.
        *   Precisely calculate and store the `Range` corresponding to the parsed parameters within the document.

4.  **Implement `parse_argument` Function:**
    *   **Objective:** Parse individual arguments, including complex string formats.
    *   **Action:**
        *   Implement parsing for single words or tokens.
        *   Add support for quoted strings (both single `''` and double `""` quotes).
        *   Incorporate logic to handle standard escape sequences within strings (e.g., `\`, `\'`, `\"`, `\n`, `\r`).
        *   Accurately determine and store the `Range` for each parsed argument.

5.  **Implement `parse_arguments` Function:**
    *   **Objective:** Aggregate multiple parsed arguments.
    *   **Action:**
        *   Iteratively call `parse_argument` to collect all arguments on a line.
        *   Define clear termination conditions for argument parsing, such as the end of the line or the closing `}` of a parameter block.
        *   Calculate and store the `Range` encompassing all parsed arguments.

6.  **Implement `parse_tag` Function:**
    *   **Objective:** Parse a complete tag structure.
    *   **Action:**
        *   Parse the tag's opening directive (e.g., `@<command>`).
        *   Utilize the newly implemented `parse_parameters` to extract any associated parameters.
        *   Utilize the newly implemented `parse_arguments` to extract any arguments following the parameters.
        *   Ensure the `Range` for the entire tag, from its opening to the end of its line, is correctly calculated.
        *   Address the `begin.column == 1` assertion: either implement validation for this or remove it if the design allows for tags not starting at the beginning of a line.

7.  **Implement `parse_anchor` Function:**
    *   **Objective:** Parse a complete anchor structure.
    *   **Action:**
        *   Parse the anchor's opening sequence (e.g., `<!-- <command>-<uuid>:<kind>`).
        *   Call `parse_parameters` and `parse_arguments` to extract their respective data.
        *   Parse the anchor's closing sequence (`-->`).
        *   Calculate and store the `Range` for the entire anchor, including its opening and closing markers.
        *   Address the `begin.column == 1` assertion as per the `parse_tag` function.

8.  **Implement `parse_text` Function:**
    *   **Objective:** Parse plain text content between tags and anchors.
    *   **Action:**
        *   Develop logic to identify and extract sequences of characters that do not conform to tag or anchor syntax.
        *   The parsing should continue until the next recognized tag/anchor pattern or the end of the document.
        *   Calculate and store the `Range` for the extracted text segment.

9.  **Refine `parse_node` and `parse_many_nodes`:**
    *   **Objective:** Ensure correct dispatching and aggregation of parsed nodes.
    *   **Action:**
        *   Update `parse_node` to correctly attempt parsing as a tag, then an anchor, and finally as plain text.
        *   Modify `parse_node` to return a well-defined `ParsingError` if no known node type can be parsed from the current position, preventing the "parsing not advanced" issue.
        *   Verify that `parse_many_nodes` correctly iterates through the document, calling `parse_node` and accumulating the resulting `Node` objects, while accurately advancing the parsing position.

10. **Add Unit Tests:**
    *   **Objective:** Ensure the correctness and robustness of the parsing logic.
    *   **Action:** Create a dedicated test module (e.g., `src/ast/mod.rs` with `#[cfg(test)]` or `src/ast/tests.rs`). Write comprehensive unit tests for each parsing function (`parse_tag`, `parse_anchor`, `parse_parameters`, `parse_argument`, `parse_text`, and the main `parse` function) covering:
        *   Valid inputs for each node type.
        *   Edge cases (e.g., empty parameters, no arguments, text at the beginning/end of the document).
        *   Invalid inputs to verify correct error handling.
        *   Complex combinations of tags, anchors, and text.
<!-- answer-fdc92f60-a607-46ad-9e31-6ff2e48b6b85:end -->

try implement