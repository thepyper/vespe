# Design Overview - Vespe Project Management

## Obiettivo Generale
Il sistema Vespe mira a fornire un framework per la gestione di progetti software assistita da agenti LLM, utilizzando il filesystem come "source of truth" per lo stato del progetto e dei task.

## Crate `project`
Il cuore della gestione del progetto sarà un sub-crate Rust chiamato `project`. Questo crate sarà responsabile di:
*   Incapsulare la logica di persistenza sul filesystem per i task e i metadati del progetto.
*   Fornire una API robusta per la creazione, il caricamento, la modifica e la gestione dello stato dei task.
*   Mantenere una rappresentazione in memoria dello stato del progetto, derivata da scansioni "on-demand" del filesystem.

## Gestione dei Task
Ogni task è un'unità di lavoro discreta con un obiettivo specifico, gestita tramite una macchina a stati e persistita sul filesystem.

### Struttura Filesystem dei Task
*   Ogni task è rappresentato da una directory con nome UID (`.vespe/tasks/tsk-UID/`).
*   La gerarchia logica task/subtask è derivata dai metadati (`parent_uid` e dipendenze), non dalla struttura fisica delle directory.
*   **File e Cartelle Chiave per Task:**
    *   `config.json`: Metadati immutabili (UID, nome, creatore, timestamp, parent_uid).
    *   `objective.md`: Descrizione mutabile dell'obiettivo.
    *   `plan.md`: Piano di esecuzione mutabile.
    *   `status.json`: Stato corrente del task, timestamp ultimo aggiornamento, progress, hash dei contenuti dei task dipendenti.
    *   `dependencies.json`: Lista di UID dei task da cui dipende.
    *   `persistent/`: Cartella per la storia interna del task (eventi timestamped per LLM).
    *   `result/`: Cartella per i risultati finali e consumabili del task.

### Macchina a Stati dei Task
I task transiteranno attraverso i seguenti stati:
*   `CREATED`: Task appena inizializzato.
*   `OBJECTIVE_DEFINED`: Obiettivo del task definito.
*   `PLAN_DEFINED`: Piano di esecuzione definito.
*   `EXECUTING`: Task in esecuzione attiva.
*   `WAITING_FOR_SUBTASKS`: Task in attesa del completamento dei subtask.
*   `NEEDS_REVIEW`: Task o dipendenza cambiata, richiede revisione.
*   `COMPLETED`: Task terminato con successo.
*   `FAILED`: Task fallito.
*   `ABORTED`: Task annullato.

### Invalidazione Basata su Hash
Le dipendenze tra task sono gestite tramite hash del contenuto della cartella `result/` del task dipendente. Se l'hash cambia, i task a valle passano allo stato `NEEDS_REVIEW`.

## Paradigma di Interazione: API come Tool per LLM e Override Utente
Le funzioni API del crate `project` fungeranno da "tool" per gli agenti LLM e saranno accessibili anche all'utente per il controllo manuale. La cartella `persistent/` sarà la "memoria" dell'agente.

## Il Manager Agent (Orchestrazione e Reazione agli Eventi)

Per automatizzare il workflow e reagire agli eventi del ciclo di vita dei task, verrà introdotto il concetto di un **Manager Agent**.

### Ruolo del Manager Agent
Il Manager Agent avrà il compito di monitorare lo stato dei task e reagire agli eventi significativi, orchestrando il flusso di lavoro.

### Comportamento Configurable (Hard-wired + LLM-driven)
Il comportamento del Manager Agent sarà configurabile, bilanciando la certezza della logica hard-wired con la flessibilità dell'intelligenza LLM:

1.  **Logica Hard-wired per Eventi Critici:**
    *   Per eventi specifici e critici (es. un task che passa allo stato `NEEDS_REVIEW`), il Manager Agent potrà essere configurato per eseguire azioni predefinite e non ambigue.
    *   Esempi:
        *   `on_needs_review`: "ask user" (richiede input umano diretto).
        *   `on_task_failed`: "notify user" (invia una notifica all'utente).
        *   Questo garantisce un "human-in-the-loop" e un comportamento prevedibile per i punti di controllo essenziali.

2.  **Comportamento LLM-driven per Intelligenza Contestuale:**
    *   Per altri eventi, o come opzione alternativa per quelli critici, il Manager Agent potrà invocare un LLM (se stesso o un altro agente) con un prompt specifico, basato sul contesto del task.
    *   Esempi di prompt per l'LLM in risposta a `on_needs_review`:
        *   "Valuta le differenze rispetto a prima ed evidenzia i possibili impatti sul piano esistente."
        *   "Proponi un nuovo piano per il task [UID] considerando il cambiamento rilevato."
        *   "Decidi se il task [UID] deve essere riavviato, ridefinito o abortito."
    *   Questo permette al Manager Agent di prendere decisioni più intelligenti e adattive, sfruttando la storia del task (`persistent/`) e l'obiettivo.

### Configurazione del Manager Agent
Il comportamento del Manager Agent sarà configurabile a livello di progetto (es. tramite un file `.vespe/manager_config.json`), con la possibilità di override a livello di task specifico se necessario. Questa configurazione definirà quali azioni intraprendere per quali eventi del ciclo di vita del task.

### Meccanismo di Reazione
Il Manager Agent monitorerà gli eventi del task (es. cambiamenti di stato) e attiverà le azioni configurate. Questo potrebbe avvenire tramite un sistema di eventi interno o un meccanismo di polling.
