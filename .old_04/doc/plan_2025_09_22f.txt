# Implementation Plan: Task Entity in `project` Crate

## Obiettivo
Implementare l'entità `Task` all'interno del sub-crate `project`, focalizzandosi sulla sua creazione, caricamento, gestione degli stati iniziali e persistenza sul filesystem, come definito nei documenti di design `doc/design_2025_09_22c.txt` e `doc/design_2025_09_22d.txt`.

## Fasi di Implementazione

### Fase 0: Setup del Crate `project`
1.  **Creazione del Crate:**
    *   Creare la directory `project/` all'interno della root del progetto (`vespe/`).
    *   Creare il file `project/Cargo.toml` con le dipendenze necessarie (`serde`, `serde_json`, `chrono`, `uuid`, `thiserror`, `sha2`).
    *   Aggiungere `project` come workspace member nel `Cargo.toml` principale di `vespe`.
2.  **Definizione delle Strutture Dati Core:**
    *   Creare `project/src/models.rs` e definire le struct `TaskConfig`, `TaskStatus`, `TaskDependencies`, `PersistentEvent`.
    *   Definire l'enum `TaskState` in `project/src/models.rs`.
    *   Definire la struct `Task` in `project/src/models.rs` (rappresentazione in memoria).
    *   Definire l'enum `ProjectError` in `project/src/error.rs` (o direttamente in `lib.rs` se preferito per semplicità iniziale).
    *   Esportare le struct e l'enum da `project/src/lib.rs`.

### Fase 1: Funzionalità di Base del Task
1.  **Gestione del Percorso Base:**
    *   Definire una funzione o una costante per ottenere il percorso base della directory dei task (es. `.vespe/tasks/`). Per ora, sarà un percorso hard-coded o configurabile tramite variabile d'ambiente per semplicità.
2.  **Generazione UID:**
    *   Implementare una funzione per generare UID univoci (es. usando la libreria `uuid`).
3.  **`create_task` API:**
    *   Implementare la funzione `project::api::create_task`.
    *   Generare un UID per il nuovo task.
    *   Creare la directory `tsk-UID/` sotto il percorso base dei task.
    *   Creare le sottodirectory `persistent/` e `result/` all'interno di `tsk-UID/`.
    *   Inizializzare `config.json` con i dati forniti e lo stato `CREATED`.
    *   Creare `objective.md` e `plan.md` vuoti.
    *   Creare `status.json` con lo stato `CREATED`.
    *   Creare `dependencies.json` vuoto.
    *   Restituire la struct `Task` caricata in memoria.
4.  **`load_task` API:**
    *   Implementare la funzione `project::api::load_task`.
    *   Dato un UID, costruire il percorso alla directory del task.
    *   Leggere e deserializzare `config.json`, `status.json`, `dependencies.json`.
    *   Leggere il contenuto di `objective.md` e `plan.md`.
    *   Costruire e restituire la struct `Task` in memoria.

### Fase 2: Transizioni di Stato Iniziali e Gestione Contenuti
1.  **`define_objective` API:**
    *   Implementare la funzione `project::api::define_objective`.
    *   Caricare il task.
    *   Validare la transizione: deve essere nello stato `CREATED`.
    *   Scrivere il `objective_content` in `objective.md`.
    *   Aggiornare `status.json` allo stato `OBJECTIVE_DEFINED` e `last_updated_at`.
    *   Restituire il task aggiornato.
2.  **`define_plan` API:**
    *   Implementare la funzione `project::api::define_plan`.
    *   Caricare il task.
    *   Validare la transizione: deve essere nello stato `OBJECTIVE_DEFINED`.
    *   Scrivere il `plan_content` in `plan.md`.
    *   Aggiornare `status.json` allo stato `PLAN_DEFINED` e `last_updated_at`.
    *   Restituire il task aggiornato.
3.  **`add_persistent_event` API:**
    *   Implementare la funzione `project::api::add_persistent_event`.
    *   Creare un file timestampato (es. `YYYYMMDDhhmmss_ms_eventtype.json`) nella cartella `persistent/` del task.
    *   Serializzare l'oggetto `PersistentEvent` nel file.
4.  **`get_all_persistent_events` API:**
    *   Implementare la funzione `project::api::get_all_persistent_events`.
    *   Leggere tutti i file dalla cartella `persistent/` del task.
    *   Deserializzare e restituire una lista di `PersistentEvent`, ordinati per timestamp.

### Fase 3: Hash dei Risultati
1.  **`calculate_result_hash` API:**
    *   Implementare la funzione `project::api::calculate_result_hash`.
    *   Scansionare ricorsivamente la cartella `result/` del task.
    *   Per ogni file, calcolare la sua hash SHA256.
    *   Combinare le hash dei file e i loro percorsi relativi in una stringa canonica.
    *   Calcolare la hash SHA256 finale di questa stringa canonica.
    *   Restituire la hash.
2.  **`add_result_file` API:**
    *   Implementare la funzione `project::api::add_result_file`.
    *   Scrivere il contenuto fornito nel file specificato all'interno della cartella `result/` del task.

### Fase 4: Test e Validazione
1.  **Unit Test:** Scrivere unit test per tutte le funzioni API implementate, coprendo:
    *   Creazione e caricamento di task.
    *   Transizioni di stato valide e non valide.
    *   Lettura/scrittura di `objective.md`, `plan.md`.
    *   Aggiunta e recupero di eventi persistenti.
    *   Calcolo dell'hash dei risultati (con e senza modifiche ai file).
2.  **Integrazione Semplice (CLI Mock):**
    *   Creare un piccolo eseguibile di test (es. in `vespe/src/bin/test_task_api.rs`) che utilizzi le API implementate per simulare un workflow di base:
        *   `create_task`
        *   `define_objective`
        *   `define_plan`
        *   `add_persistent_event`
        *   `add_result_file`
        *   `complete_task` (anche se la transizione non è ancora implementata, si può testare il calcolo hash)
        *   `load_task` e verifica dello stato.

## Criteri di Successo
*   Il crate `project` compila senza errori.
*   Tutti gli unit test passano.
*   L'eseguibile di test dimostra la corretta creazione, modifica e caricamento dei task sul filesystem.
*   La struttura del filesystem per i task è conforme al design.

## Dipendenze
*   `serde`, `serde_json` per serializzazione/deserializzazione.
*   `chrono` per la gestione dei timestamp.
*   `uuid` per la generazione di UID.
*   `thiserror` per la gestione degli errori.
*   `sha2` per il calcolo degli hash.

## Percorso Base dei Task
Per l'implementazione iniziale, il percorso base per le directory dei task sarà `C:\Proj\xxx\025_006.Vespe\vespe\.vespe\tasks\`. Questo percorso sarà gestito internamente dal crate `project` e potrà essere reso configurabile in futuro.
