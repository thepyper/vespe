Piano di implementazione per il binario `tool-format-tester`

**Obiettivo:** Rifattorizzare il binario `tool-format-tester` per implementare una pipeline che testa la capacità di un modello (HERO) di seguire formati di tool-calling specifici, validandone l'output.

**Concetto Chiave:** Introdurre un trait `ToolCallPolicy` per disaccoppiare la logica di ogni formato di tool-calling.

---

### Fase 1: Definizione delle Abstraction (`ToolCallPolicy`)

1.  **Creare un nuovo modulo:** Creare il file `src/bin/tool-format-tester/policies.rs`.

2.  **Definire la struttura dati per il risultato:** All'interno di `policies.rs`, definire una struct `ParsedToolCall` che rappresenterà un tool call validato e parsato. Conterrà il nome del tool e i parametri.
    ```rust
    pub struct ParsedToolCall {
        pub name: String,
        pub parameters: serde_json::Value, // Flessibile per gestire vari formati
    }
    ```

3.  **Definire il trait `ToolCallPolicy`:** Nello stesso file, definire il trait.
    ```rust
    pub trait ToolCallPolicy {
        // Restituisce il nome univoco della policy (es. "json", "xml").
        fn name(&self) -> &str;

        // Costruisce la sezione del system prompt che istruisce HERO sul formato da usare.
        fn build_prompt_section(&self, handlebars: &Handlebars) -> Result<String>;

        // Valida l'output del modello HERO. Se valido, restituisce i tool call parsati.
        // Se non valido, restituisce un errore descrittivo.
        fn validate_and_parse(&self, model_output: &str) -> Result<Vec<ParsedToolCall>>;
    }
    ```

### Fase 2: Prima Implementazione Concreta (`JsonToolCallPolicy`)

1.  **Creare la struct per la policy JSON:** In `policies.rs`, creare `pub struct JsonToolCallPolicy;`.

2.  **Implementare il trait:**
    -   `name()`: Restituirà `"json"`.
    -   `build_prompt_section()`: Renderizzerà un nuovo template Handlebars (`json_policy_prompt.hbs`) che spiega come formattare i tool call in JSON.
    -   `validate_and_parse()`: Implementerà la logica per estrarre e parsare il blocco JSON dall'output del modello (gestendo anche eventuali ```json ... ```) usando `serde_json`.

3.  **Creare directory e template per le policy:**
    -   Creare una nuova directory: `src/bin/tool-format-tester-templates/`.
    -   Creare il file `json_policy_prompt.hbs` al suo interno.

### Fase 3: Integrazione nella Pipeline Principale

1.  **Aggiornare gli argomenti CLI:** In `cli_args.rs`, modificare o aggiungere un argomento per selezionare la policy da usare (es. `--policy json`).

2.  **Modificare `main.rs`:**
    -   Creare un "registro" di policy disponibili (es. un `Vec<Box<dyn ToolCallPolicy>>`).
    -   All'avvio, selezionare la policy richiesta dall'argomento CLI.
    -   Rimuovere la logica del modello MARKER (il "Passo 3" del vecchio `data-generator`) e la relativa chiamata a `label_student_response`, poiché la validazione è ora responsabilità della policy.

3.  **Modificare `pipeline.rs`:**
    -   La funzione `get_student_response` dovrà accettare un riferimento alla policy selezionata (`&dyn ToolCallPolicy`).
    -   Userà `policy.build_prompt_section()` per ottenere le istruzioni sul formato e le inserirà nel system prompt per HERO.

4.  **Eseguire la validazione:**
    -   Nel loop principale di `main.rs`, dopo aver ricevuto la risposta da HERO (`hero_response_raw`), invocare `policy.validate_and_parse(&hero_response_raw)`.
    -   Registrare (loggare) il risultato della validazione: successo o fallimento con l'errore specifico.

### Fase 4: Refactoring e Pulizia

1.  **Separare i template:** Modificare `prompt_templates.rs` nel nuovo binario per caricare i template dalla nuova directory `../tool-format-tester-templates/` invece che da `../data_generator_templates/`.

2.  **Adattare il salvataggio:** La funzione `save_labeled_example` è ora obsoleta. Sarà sostituita da una nuova logica che salva i risultati dei test, includendo il prompt, la risposta del modello e l'esito della validazione (successo/fallimento e dati parsati/errore).

3.  **Rimuovere codice inutilizzato:** Eliminare le parti del codice copiate da `data-generator` che non sono più pertinenti, come la logica di labeling e il modello MARKER.
