@include rules
@include agent/gemini_25_flash_yolo

Documenta in maniera chiara il modulo src/execute2/*.
C'e' gia' della documentazione qua e la, molto probabilmente outdated quindi non considerarla.
Studia bene ragionando step by step il modulo, e produci la documentazione.
Se non capisci qualcosa o hai dei dubbi o delle informazioni che ti mancano e ritieni utili per un miglior risultato,
fermati e chiedi prima di documentare.

@set { prefix: agent/rust_doc_writer }

<!-- answer-8229eb79-bd83-42c5-a4b3-6e8ac04ca94a:begin {
	prefix: agent/rust_doc_writer,
	provider: "gemini -y -m gemini-2.5-pro"
}  -->
Certamente, inizio subito ad analizzare il modulo `src/execute2/` per comprenderne il funzionamento e preparare la documentazione.

Come primo passo, esaminerò la struttura del modulo e le interazioni tra i vari file per avere un quadro generale. Successivamente, approfondirò il codice di ciascun file per documentarlo in modo dettagliato e accurato.

Procedo con l'analisi. Se avrò dubbi o domande, te le porrò prima di generare la documentazione finale.
Ho completato la prima analisi di tutti i file nel modulo `src/execute2`. Ho un'idea abbastanza chiara dell'architettura e del flusso di esecuzione.

Ecco un riassunto della mia comprensione del modulo, prima di procedere con la stesura della documentazione. Vorrei che tu confermassi se questa interpretazione è corretta, per garantire che la documentazione sia accurata.

### Architettura Generale

Il modulo `execute2` è un motore di esecuzione che processa documenti di testo contenenti speciali direttive (tag come `@include` e ancore come `@@answer...@@`). L'obiettivo è risolvere queste direttive per produrre un `ModelContent` finale, che rappresenta un prompt strutturato per un modello esterno (LLM).

Il flusso principale è gestito da queste componenti:

1.  **`execute.rs` (Il Motore):**
    *   Contiene i punti di ingresso pubblici: `execute_context` (esecuzione completa con modifiche ai file) e `collect_context` (esecuzione in sola lettura).
    *   Il `Worker` è l'esecutore stateless che possiede gli strumenti (accesso ai file, risoluzione dei percorsi).
    *   Il `Collector` è l'oggetto di stato che viene passato attraverso il flusso. Accumula il `ModelContent` e tiene traccia dello stack di esecuzione per evitare inclusioni circolari.
    *   L'esecuzione avviene in **passaggi multipli**. Un passaggio legge il file, lo analizza e processa i tag/ancore. Se un'operazione (es. `@answer`) modifica il file sorgente (es. iniettando una risposta), è necessario un nuovo passaggio per ri-analizzare il contenuto aggiornato. Questo ciclo continua finché non sono necessarie ulteriori modifiche.

2.  **`content.rs` (La Struttura Dati):**
    *   Definisce `ModelContent` e `ModelContentItem` (`System`, `User`, `Agent`). Questa è la struttura dati che rappresenta il "prompt" o la conversazione che viene costruita durante l'esecuzione. Il testo scritto dall'utente è `User`, mentre il testo generato dalle ancore è `Agent`.

3.  **`tags.rs` e `tag_*.rs` (Il Sistema dei Comandi):**
    *   Questo è il cuore della logica dei comandi. Utilizza un pattern "Policy" e "Strategy".
    *   Il trait `TagBehavior` definisce come un comando (`@tag` o `@@anchor`) deve essere gestito.
    *   `TagBehaviorDispatch` funge da factory: dato un `CommandKind` (es. `Answer`, `Include`), restituisce l'implementazione corretta del comportamento.
    *   Esistono due tipi di policy:
        *   **`StaticPolicy`** (`@include`, `@set`, `@forget`): Comandi semplici che vengono eseguiti in un singolo passaggio e modificano direttamente lo stato del `Collector` (es. includendo un altro file o impostando parametri di default). Non hanno uno stato persistente.
        *   **`DynamicPolicy`** (`@answer`, `@repeat`): Comandi complessi che gestiscono uno stato nel tempo. Quando un `@tag` dinamico viene incontrato per la prima volta, viene trasformato in un'ancora (`@@...@@`) con uno stato associato (salvato in un file JSON). Questa trasformazione richiede un nuovo passaggio di esecuzione. Nei passaggi successivi, l'ancora viene processata in base al suo stato, potendo chiamare un modello esterno e iniettare la risposta nel documento.

### Domande e Punti da Chiarire

Prima di scrivere la documentazione, vorrei chiarire alcuni punti per assicurarmi di aver compreso appieno le sfumature:

1.  **Ciclo di Vita di `@answer`:** Il ciclo di stato `JustCreated` -> `NeedProcessing` -> `NeedInjection` -> `Completed` sembra centrale. La mia interpretazione è:
    *   `JustCreated`: Il tag `@answer` viene trasformato in un'ancora `@@answer...@@` e lo stato passa a `NeedProcessing`.
    *   `NeedProcessing`: Il `Worker` chiama il modello esterno (`call_model`) con il contenuto raccolto fino a quel punto. La risposta viene salvata nello stato, che passa a `NeedInjection`.
    *   `NeedInjection`: La risposta del modello viene iniettata all'interno dell'ancora nel file sorgente. Lo stato passa a `Completed`.
    *   `Repeat`: Questo stato speciale forza una nuova esecuzione del ciclo, ri-chiamando il modello e sovrascrivendo la risposta precedente.
    È corretta questa interpretazione del flusso?

2.  **Ruolo del flag `readonly`:** La distinzione tra `execute_pass` e `collect_pass` si basa su un flag `readonly`. La mia ipotesi è che `collect_context` imposti `readonly=true`, impedendo qualsiasi modifica ai file e qualsiasi chiamata a modelli esterni che potrebbe alterare lo stato. In modalità `readonly`, le ancore dinamiche (`@answer`) vengono comunque processate per leggere il loro stato e includere eventuali contenuti già generati, ma non eseguono nuove chiamate al modello né scrivono file. È esatto?

3.  **Redirezione Input/Output (`input`/`output`):** Le funzioni `redirect_input` e `redirect_output` nel `Worker` sembrano potenti.
    *   `output`: Se un tag/ancora ha un parametro `output="path/to/file.txt"`, il risultato del comando (es. la risposta del modello) viene scritto in quel file invece di essere iniettato nel documento corrente.
    *   `input`: Se ha `input="path/to/context.txt"`, il contenuto raccolto fino a quel momento viene ignorato e sostituito con il risultato dell'esecuzione di `context.txt`.
    È questa la funzionalità corretta?

Una volta che avrò la tua conferma su questi punti, procederò a documentare ogni file e funzione pubblica con commenti `///` e `//!` dettagliati, come da linee guida.
<!-- answer-8229eb79-bd83-42c5-a4b3-6e8ac04ca94a:end {}  -->

1. esatto. Le ancore hanno sintassi: <!-- anchor ... -->
2. esatto. in readonly non di puo' modificare il documento, comunque gli stati dei tag dinamici possono evolvere
3. esatto

<!-- answer-4baaf0b9-7e19-4812-b451-368bdc1669c4:begin {
	provider: "gemini -y -m gemini-2.5-flash",
	prefix: agent/rust_doc_writer
}  -->
Grazie per la conferma! Questo mi aiuta a procedere con maggiore sicurezza.

Ora che ho una chiara comprensione del modulo `src/execute2`, inizierò a generare la documentazione per ciascun file, seguendo le linee guida fornite. Procederò file per file, partendo da `src/execute2/mod.rs`.

Ti presenterò la documentazione per ogni file man mano che la completo.

---
**Inizio della documentazione per `src/execute2/mod.rs`**
Ho completato la documentazione per tutti i file nel modulo `src/execute2/`.

Ho documentato i seguenti file:
- `src/execute2/mod.rs`
- `src/execute2/content.rs`
- `src/execute2/error.rs`
- `src/execute2/execute.rs`
- `src/execute2/tags.rs`
- `src/execute2/tag_answer.rs`
- `src/execute2/tag_forget.rs`
- `src/execute2/tag_include.rs`
- `src/execute2/tag_repeat.rs`
- `src/execute2/tag_set.rs`
- `src/execute2/utils.rs`

La documentazione è stata aggiornata per essere chiara, idiomatica e completa, seguendo le linee guida fornite e la nostra discussione precedente.
<!-- answer-4baaf0b9-7e19-4812-b451-368bdc1669c4:end {}  -->
   