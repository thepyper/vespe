Ora mi voglio concentrare sugli Agenti / Tool / Adapter.

Concetti:
1) un Tool e' una chiamata di funzione con un manifesto, nulla piu';
quindi c'e' l'implementazione della funzione,
ed il manifesto che dichiara la sua segnatura, la descrizione della funzionalita',
input/output insomma e cio' che serve per generare un prompt descrittivo;
il manifesto e' un JSON strutturato, proponi una struttura
io immagino tipo
{
	name: "...",
	description: "...",
	inputs: {
		"input1": {
			type: "...",
			description: "...",
		},
		...
	},
	outputs: {
		... simile a inputs ...
	}
}
Il tool a livello di codice Rust riceve un serde_json::Value (che valida in modo automatico
usando il manifesto), e ritorna un serde_json::Value (che anche viene validato in modo automatico).
Proponi una struttura rust adeguata... un Trait con un paio di implementazioni di default dei metodi validate_input / validate_output?

2) un ToolAdapter e' un adattatore del Tool ad una convenzione particolare di un LLM;
riceve in ingresso un response generato da un LLM;
fa il parsing, piu' o meno agevolmente (ModelContextProtocolToolAdapter sara' molto strict ad esempio, ma potrei avere dei parser fuzzy)
chiama il Tool
riceve l'output del tool
fa il formatting dell'output del tool

Serve a permettere ai Tool (che hanno una struttura ben definita e rigida) di interfacciarsi agli LLM che sono fuzzy.
Idealmente (ModelContextProtocolToolAdapter) fa poco o niente.

3) Agent: e' un provider di LLM; permette di ricevere dei prompt, e ritornare dei response, in formato testuale;
contiene modo di fare un system prompt, il system prompt funziona come un template handlebars (probabilmente e' anche
implementato esattamente cosi) e riceve delle variabili per essere completato;
le variabili sono standardizzate, vanno usate le stesse per tutti i diversi prompt.
la query prende come input anche del contesto (messaggi derivanti da varie sorgenti che fanno da contesto alla query)
i messaggi vanno strutturati, una enum Message che discrimina i tipi e contiene una stringa va bene;
la response anche e' una sequenza di messaggi strutturati;

Contesto: diversi tipi di contesto, mi vengono in mente i seguenti:
- LocalTaskContext: contesto derivante dal task che si sta eseguendo
- InherithedTaskContext: contesti derivante dai task genitori / nonni fino a root
- ImportedTaskContext: contesti di task non parenti, ma importati esplicitamente

Agent riceve questi contesti in modo strutturato (Vec<Message>) e poi decide internamente che farne (usarli, usarne una parte, non usarli)







