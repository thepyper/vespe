## Piano di Implementazione per ToolAdapter (Revisione Semplificata)

Basandomi sul documento `doc/design_2025_09_26c.txt`, `doc/design_2025_09_26b.txt` e le tue recenti chiarificazioni e la richiesta di semplificazione, ho formulato un piano rivisto per l'implementazione del `ToolAdapter`.

**Obiettivo:** Introdurre il concetto di `ToolAdapter` come `trait` per astrarre l'interazione tra `Tool` e LLM, e dotare la struct `Tool` di un metodo `execute` placeholder per l'esecuzione diretta, posticipando l'introduzione di `ToolImplementation` e `ToolRegistry`.

---

### Fase 1: Dotare la struct `Tool` di un metodo `execute` (Semplificato)

Questa fase si concentra sull'abilitazione dell'esecuzione diretta da parte della struct `Tool`, senza introdurre complessità aggiuntive per ora.

1.  **Modificare `src/tool.rs`:**
    *   **Mantenere `implementation_details` in `ToolConfig`**: Questo campo sarà utilizzato dal metodo `execute` del `Tool` per determinare (in futuro) come eseguire il tool. Per ora, servirà come riferimento per il placeholder.
    *   **Aggiungere un metodo `execute` alla struct `Tool`**: Questo metodo sarà responsabile dell'interpretazione di `self.config.implementation_details` e dell'esecuzione effettiva del tool. Per ora, sarà un placeholder che simula l'esecuzione.
        ```rust
        use async_trait::async_trait;
        use serde_json::Value;
        use crate::error::ProjectError;

        impl Tool {
            // ... metodi esistenti ...

            pub async fn execute(&self, inputs: Value) -> Result<Value, ProjectError> {
                // TODO: Implementare la logica di esecuzione basata su self.config.implementation_details
                // Per ora, un placeholder che simula l'esecuzione.
                // In futuro, qui potrebbe esserci un match su un campo di implementation_details
                // per chiamare diverse logiche di esecuzione (es. comando shell, funzione Rust).
                tracing::warn!("Tool execution for '{}' is a placeholder. Inputs: {:?}. Implementation details: {:?}", self.config.name, inputs, self.config.implementation_details);
                Ok(serde_json::json!({ "status": "success", "message": "Placeholder execution", "tool_name": self.config.name, "inputs_received": inputs }))
            }
        }
        ```
    *   **Rimuovere la definizione della struct `ToolCall`**: Continueremo a utilizzare direttamente `MessageContent::ToolCall`.
    *   **Aggiungere `use async_trait::async_trait;`**, `use serde_json::Value;` e `use crate::error::ProjectError;` se non già presenti.

2.  **Rimuovere `src/tool_registry.rs` dal piano**: L'introduzione di `ToolImplementation` e `ToolRegistry` è posticipata.

3.  **Aggiornare `src/lib.rs`:**
    *   Assicurarsi che non ci siano esportazioni relative a `tool_registry` o `ExecutableTool`.

---

### Fase 2: Definire il trait `ToolAdapter` (Aggiustato)

Questa fase introduce il `trait` `ToolAdapter` che definisce l'interfaccia per l'adattamento di un `Tool` a un LLM, utilizzando `MessageContent::ToolCall` per gli input parsati e `serde_json::Value` per gli output raw.

1.  **Creare un nuovo file `src/tool_adapter.rs`:**
    *   **Definire l'enum `ToolAdapterError`**: Per gestire errori specifici dell'adattatore (es. errori di parsing, errori di esecuzione del tool).
        ```rust
        #[derive(Debug, thiserror::Error)]
        pub enum ToolAdapterError {
            #[error("Parsing LLM response failed: {0}")]
            ParsingError(String),
            #[error("Tool execution failed: {0}")]
            ToolExecutionError(#[from] crate::error::ProjectError),
            #[error("Invalid tool call: {0}")]
            InvalidToolCall(String),
            #[error("Tool not found: {0}")]
            ToolNotFound(String),
            // Altri errori specifici...
        }
        ```
    *   **Definire il trait `ToolAdapter`**: Questo trait richiederà un riferimento al `Tool` che sta adattando. Il metodo `execute_tool` avrà un'implementazione di default che chiama direttamente `Tool::execute`.
        ```rust
        use async_trait::async_trait;
        use serde_json::Value;
        use crate::tool::Tool;
        use crate::memory::MessageContent;
        use crate::error::ProjectError;

        #[async_trait]
        pub trait ToolAdapter: Send + Sync {
            /// Restituisce il nome dell'adattatore.
            fn name(&self) -> &str;

            /// Restituisce un riferimento al Tool adattato.
            fn tool(&self) -> &Tool;

            /// Genera una descrizione del tool specifica per l'LLM (es. JSON Schema per OpenAI).
            fn generate_tool_description(&self) -> String;

            /// Parsa la risposta raw dell'LLM in una MessageContent::ToolCall strutturata.
            fn parse_llm_response(&self, llm_response: &str) -> Result<MessageContent::ToolCall, ToolAdapterError>;

            /// Esegue il Tool sottostante con gli input parsati.
            /// Ha un'implementazione di default che chiama Tool::execute.
            async fn execute_tool(&self, tool_call: &MessageContent::ToolCall) -> Result<Value, ToolAdapterError> {
                let tool = self.tool();
                tool.execute(tool_call.inputs.clone()).await
                    .map_err(|e| ToolAdapterError::ToolExecutionError(e))
            }

            /// Formatta l'output raw del Tool in una stringa adatta al contesto dell'LLM.
            fn format_tool_output(&self, tool_output: Value) -> String;
        }
        ```
    *   **Aggiungere `use async_trait::async_trait;`**, `use serde_json::Value;`, `use crate::error::ProjectError;` e `use thiserror::Error;` se non già presenti.

2.  **Aggiornare `src/lib.rs`:**
    *   Esportare il nuovo modulo `tool_adapter`.
        ```rust
        pub mod tool_adapter;
        pub use tool_adapter::*;
        ```

---

### Punti ancora da chiarire (per il prossimo piano):

*   **Implementazioni concrete di `ToolAdapter`**: Questo piano definisce solo il trait. Le implementazioni concrete (es. per OpenAI, Ollama, o un `ModelContextProtocolToolAdapter` strict) saranno definite in un piano successivo.
*   **Integrazione di `ToolAdapter` con `Project` e `Agent`**: Come gli `Agent` caricheranno e utilizzeranno questi `ToolAdapter`s. Questo sarà un passo successivo.
*   **Implementazione reale di `Tool::execute`**: La logica attuale è un placeholder. L'implementazione di un `ToolRegistry` e `ToolImplementation` verrà affrontata in un piano futuro per rendere `Tool::execute` funzionale.

Attendo la tua approvazione per questo piano semplificato.