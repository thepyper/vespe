@include rules
@include provider/gemini_25_pro_yolo
@include agent/coder

C'e' un po di complessita' che mi sta scoppiando in mano, vorrei sistemare.
Guarda in src/execute2/state.rs, ci sono diversi stati ma c'e' molta ripetizione.
Vengono usati in src/execute2/execute.rs, leggi anche li.
Vorrei sistemare, in modo da risolvere le seguenti:

Prima idea:

C'e' parte di State che e' comune a tutti, vorrei separare le strutture in parte fissa (.status attualmente, ma aggiungero' altre cose) e parte dipendente dal tipo di State (i campi vari di AnswerState, DeriveState, etc...); per questo mi viene in mente una enum tipo:

enum State
{
    AnswerState{ common: CommonState, ... i campi particolari di AnswerState ....}
}

struct CommonState
{
    status: AnchorStatus,
}

Seconda idea, piu raffinata:

In realta' State e' un po strano perche' in parte e' particolare, in parte e' generale, e non so come risolvere questa tensione.
Attualmente ho risolto gestendo uno Status comune a tutti (che in realta' e' quasi ok, ma non esattamente aderente per tutti),
ed il resto dei campi dettagliato per ogni diverso State, e output letto usando un metodo.
Un po una porcheria.

Devo gestire i seguenti tipi di "flusso":

1) flusso A: (answer, derive, decide, inline (che in realta' non ha llm query ma read-file))
    - JustCreated -> anchor vuota, solo inserita in testo (passaggio tag-independent)
    - NeedRepeat -> anchor sporca, da svuotare per tornare a JustCreated (vuota e pulita) (passaggio tag-indepentent)
    - NeedProcessing -> anchor ha raccolto il context da processare, e deve processarlo (passaggio molto tag-dependent) 
    - NeedInjection -> anchor ha a disposizione del text da iniettare nel context (tag-indepentent)
    - Complete -> anchor completata ed inattiva

2) flusso B: (repeat)
    - JustCreated -> anchor vuota, solo inserita in testo  
    - NeedInjection -> anchor ha a disposizione del text da iniettare nel context, ovvero alterare la anchor contenente
    - Complete -> anchor completata ed inattiva

3) flusso C: (include, set)
    senza anchor, flusso basato solo sul tag senza modifiche al context di nessun tipo,
    solo comportamenti particolari del tag.

Come questo puo' essere gestito da State?

Terza idea, stellare:

In realta' poi l'ideale sarebbe una architettura in cui io non scrivo una porcheria come in execute.rs attuale,
in cui il flusso di un tag e' spezzettato in mille punti, ma vorrei avere uno (o piu') trait per i tag, che poi
vanno completati per implementare i tag.

Mi sembra moooooolta roba da digerire, chissa se ce la fai?

Se riesci, ragiona per step, e fammi una proposta di refactoring seria per ottenere un codice scritto meglio
di come e' fatto ora. Parlo di ergonomia di scrittura, di avere facilita' di aggiunta di nuovi tag,
di separazione dell'engine dai dettagli dei tag.
La funzionalita' in realta' mi va benissimo come e' fatta, con gli step fatti cosi, eccetera.

Non eseguire niente, pianifica solamente ed esponimi con massima chiarezza e dettaglio il piano.


Certamente. Ho analizzato la tua richiesta, le tue idee e il codice sorgente in `src/execute2/state.rs` e `execute.rs`.

La tua analisi è eccellente e centra perfettamente il problema. L'architettura attuale mescola la logica del "motore" di esecuzione con i dettagli specifici di ogni tag, rendendo il codice ripetitivo, difficile da estendere e con una manutenibilità complessa. La tua "terza idea, stellare" è la direzione giusta: un'architettura a plugin basata su `trait` per i tag.

Ecco un piano di refactoring dettagliato, suddiviso in fasi progressive, per raggiungere quell'obiettivo. Ogni fase è un passo concreto che migliora la codebase e prepara la strada per la successiva.

### Obiettivo Finale

Separare nettamente il **motore di esecuzione** (l'orchestratore che gestisce il ciclo di vita delle ancore) dalla **logica dei tag** (le azioni specifiche che ogni tag compie). Questo renderà l'aggiunta di nuovi tag un processo semplice e isolato, senza dover modificare il motore principale.

---

### Piano di Refactoring Proposto

#### Fase 1: Ristrutturazione del Modello Dati (`State`)

Questa fase implementa la tua "prima idea". L'obiettivo è eliminare la duplicazione nelle definizioni degli stati e creare una struttura dati unificata e coerente.

1.  **Definire `CommonState`**: Creeremo una struct che conterrà tutti i dati comuni a qualsiasi stato associato a un'ancora.
    ```rust
    // In src/execute2/state.rs

    pub struct CommonState {
        pub status: AnchorStatus,
        // Aggiungeremo qui altri campi comuni in futuro, 
        // es. ID dell'ancora, posizione, etc.
    }
    ```

2.  **Definire `StateKind`**: Creeremo una `enum` che conterrà solo i dati *specifici* per ogni tipo di stato. Le attuali `AnswerState`, `DeriveState` verranno trasformate in varianti di questa enum, contenendo solo i loro campi unici.
    ```rust
    // In src/execute2/state.rs

    pub struct AnswerStateData {
        pub model: String,
        pub prompt: String,
        pub output: Option<String>,
    }

    pub struct DeriveStateData {
        pub from: String,
        pub output: Option<String>,
    }

    // ... e così via per gli altri ...

    pub enum StateKind {
        Answer(AnswerStateData),
        Derive(DeriveStateData),
        Decide(DecideStateData),
        Inline(InlineStateData),
        Repeat(RepeatStateData),
        // Nota: i tag senza stato come 'include' e 'set' non appariranno qui.
    }
    ```

3.  **Unificare in `State`**: La `State` principale diventerà una struct che combina le due precedenti.
    ```rust
    // In src/execute2/state.rs

    pub struct State {
        pub common: CommonState,
        pub kind: StateKind,
    }

    impl State {
        // Metodi helper per accedere ai dati in modo sicuro e pulito
        pub fn output(&self) -> Option<&str> {
            match &self.kind {
                StateKind::Answer(d) => d.output.as_deref(),
                StateKind::Derive(d) => d.output.as_deref(),
                // ... etc.
            }
        }
    }
    ```

**Beneficio di questa fase**: Il modello dati diventa pulito, non ripetitivo e più facile da gestire. La logica che dipende solo da `AnchorStatus` può operare su `CommonState` senza conoscere i dettagli specifici del tag.

---

#### Fase 2: Introduzione del Trait `TagProcessor`

Questa è la fase cruciale che implementa la tua "terza idea". Definiamo un'interfaccia (un `trait`) che ogni tag dovrà implementare.

1.  **Definire il `trait`**: Creeremo un nuovo file, ad esempio `src/execute2/tag_processor.rs`, con la definizione del nostro trait. Questo trait astrae il ciclo di vita di un tag stateful.
    ```rust
    // In src/execute2/tag_processor.rs

    use super::state::{State, StateKind, CommonState};

    // Azione che il motore deve compiere dopo l'avanzamento dello stato
    pub enum TagAction {
        Inject(String), // Inietta questo testo
        NoOp,           // Non fare nulla
        Completed,      // Il tag ha finito il suo ciclo
    }

    pub trait TagProcessor: Send + Sync {
        /// Ritorna il nome del tag (es. "answer")
        fn name(&self) -> &'static str;

        /// Crea lo stato iniziale per questo tag quando viene incontrata una nuova ancora.
        fn initial_state(&self, /* parametri dal tag, es. model, prompt */) -> Result<StateKind, anyhow::Error>;

        /// Fa avanzare lo stato del tag. Questa è la funzione centrale.
        /// Contiene la logica per passare da uno stato all'altro (es. da NeedProcessing a NeedInjection).
        fn advance(&self, state: &mut State) -> Result<TagAction, anyhow::Error>;
    }
    ```
    La funzione `advance` conterrà la logica che oggi è sparsa in `execute.rs`. Ad esempio, per il tag `answer`, `advance` controllerà se `state.common.status` è `NeedProcessing`. Se sì, eseguirà la query LLM, salverà il risultato in `state.kind` e ritornerà `TagAction::Inject(result)`.

---

#### Fase 3: Refactoring del Motore di Esecuzione (`execute.rs`)

Ora modifichiamo `execute.rs` per usare il nostro nuovo `trait`. Il motore diventerà generico.

1.  **Creare un `TagRegistry`**: Il motore avrà bisogno di un modo per trovare l'implementazione `TagProcessor` corretta per un dato nome di tag. Una `HashMap` è perfetta per questo.
    ```rust
    // In execute.rs o in un nuovo modulo 'engine'
    use std::collections::HashMap;
    use super::tag_processor::TagProcessor;

    pub struct TagRegistry {
        processors: HashMap<&'static str, Box<dyn TagProcessor>>,
    }

    impl TagRegistry {
        pub fn new() -> Self {
            // Qui registriamo tutte le nostre implementazioni di tag
            let mut processors: HashMap<&'static str, Box<dyn TagProcessor>> = HashMap::new();
            
            let answer_proc = Box::new(AnswerProcessor); // da definire nella fase 4
            processors.insert(answer_proc.name(), answer_proc);

            let derive_proc = Box::new(DeriveProcessor); // da definire nella fase 4
            processors.insert(derive_proc.name(), derive_proc);
            
            // ... e così via per tutti i tag
            
            Self { processors }
        }

        pub fn get(&self, name: &str) -> Option<&dyn TagProcessor> {
            self.processors.get(name).map(|b| b.as_ref())
        }
    }
    ```

2.  **Semplificare il ciclo di `execute`**: Il loop principale di `execute` non avrà più un `match` gigante sul nome del tag. Invece, userà la `TagRegistry` per delegare il lavoro.
    ```rust
    // Pseudo-codice di come diventerà il loop in execute.rs

    let registry = TagRegistry::new();

    for anchor in find_anchors_to_process() {
        let mut state = load_state_for_anchor(anchor); // Carica lo State dal DB o memoria
        
        if let Some(processor) = registry.get(anchor.tag_name()) {
            // Delega tutta la logica di business al processore del tag!
            match processor.advance(&mut state) {
                Ok(TagAction::Inject(text)) => {
                    inject_text_into_document(text);
                    state.common.status = AnchorStatus::NeedInjection; // o un altro stato
                },
                Ok(TagAction::Completed) => {
                    state.common.status = AnchorStatus::Complete;
                },
                // ... etc.
            }
        }
        
        save_state_for_anchor(anchor, state); // Salva lo stato aggiornato
    }
    ```

**Beneficio di questa fase**: `execute.rs` non conosce più i dettagli di "answer" o "derive". Sa solo come orchestrare un ciclo di stati guidato da un `TagProcessor`. La complessità è ora decentralizzata.

---

#### Fase 4: Implementazione dei `TagProcessor`

Spostiamo la logica attualmente in `execute.rs` dentro le implementazioni specifiche del nostro nuovo `trait`.

1.  **Creare `src/execute2/processors/answer.rs`**:
    ```rust
    // In src/execute2/processors/answer.rs
    use super::super::tag_processor::{TagProcessor, TagAction};
    use super::super::state::{State, StateKind, AnswerStateData};

    pub struct AnswerProcessor;

    impl TagProcessor for AnswerProcessor {
        fn name(&self) -> &'static str { "answer" }

        fn initial_state(&self, /*...*/) -> Result<StateKind, ...> {
            // Logica per creare AnswerStateData dai parametri del tag
            Ok(StateKind::Answer(AnswerStateData { ... }))
        }

        fn advance(&self, state: &mut State) -> Result<TagAction, ...> {
            if let StateKind::Answer(data) = &mut state.kind {
                match state.common.status {
                    AnchorStatus::NeedProcessing => {
                        // QUI va la logica per chiamare l'LLM
                        let result = call_llm(&data.prompt, &data.model)?;
                        data.output = Some(result.clone());
                        state.common.status = AnchorStatus::NeedInjection;
                        return Ok(TagAction::Inject(result));
                    }
                    AnchorStatus::NeedInjection => {
                        // Logica per quando il testo è stato iniettato
                        state.common.status = AnchorStatus::Complete;
                        return Ok(TagAction::Completed);
                    }
                    _ => Ok(TagAction::NoOp)
                }
            } else {
                Err(anyhow::anyhow!("Stato non valido per AnswerProcessor"))
            }
        }
    }
    ```
2.  **Fare lo stesso per `DeriveProcessor`, `RepeatProcessor`, etc.** in file separati. Ogni file sarà autonomo e conterrà tutta la logica per un singolo tag.

---

#### Fase 5: Gestione dei Tag "Stateless" (Flusso C)

I tag come `include` e `set` non si adattano bene al modello di stato a lungo termine. Possiamo gestirli in due modi:

1.  **Opzione A (Preferita)**: Creare un secondo, più semplice `trait` `StatelessTagProcessor` con un singolo metodo `execute(&self, ...)` che viene chiamato una sola volta. La `TagRegistry` conterrà entrambi i tipi di processori.
2.  **Opzione B (Più Semplice)**: Nell'engine `execute.rs`, prima di entrare nel ciclo degli stati, avere un `match` per gestire questi casi speciali.

Proporrei di iniziare con l'Opzione B per semplicità e poi, se necessario, evolvere verso l'Opzione A.

### Riassunto dei Benefici

1.  **Ergonomia**: Per aggiungere un nuovo tag `new_tag`, dovrai solo:
    *   Creare `src/execute2/processors/new_tag.rs`.
    *   Implementare il `trait TagProcessor`.
    *   Registrarlo nella `TagRegistry`.
    *   **Nessuna modifica al motore `execute.rs`**.
2.  **Separazione delle Responsabilità**: Il motore orchestra, i processori eseguono. Codice pulito e disaccoppiato.
3.  **Testabilità**: Ogni `TagProcessor` può essere testato in isolamento, senza dover eseguire l'intero motore di `execute`.
4.  **Chiarezza**: Tutta la logica di un tag è contenuta in un unico file, facile da trovare, leggere e modificare.

Questo piano mira a trasformare la codebase da un monolite procedurale a un sistema più robusto, modulare e facile da mantenere, seguendo le migliori pratiche di software engineering in Rust.

Attendo la tua approvazione per iniziare con la **Fase 1**.


Vedo dei difetti e imprecisioni nel piano:

1) forse cercare di rendere State parte common e parte dettaglio introduce una tensione inutile.
   nel momento in cui un trait sara' fatto bene, avra' un tipo generico T per lo stato e tutto si 
   interfaccera' al trait, e non allo stato, quindi e' un passaggio inutile rendere lo stato common + dettaglio.

2) il TagProcessor/advance perde di vista che ci sono 2 pass con scopi molto diversi: eseguire task "fuori dal context", ma leggendo il context con collector, oppure "modificare il context"; questa divisione a me pare molto funzionale, ed e' centrale al funzionamento dell'engine.

riprova, capendo queste cose bene.

<!-- answer-53639206-fb2e-4fcd-b8ae-eda364547da3:begin   -->
Hai assolutamente ragione. Le tue osservazioni sono acute e colgono due punti deboli chiave della mia prima proposta. Tento di forzare una struttura (`CommonState`) che diventa superflua con un'astrazione migliore, e fondo due fasi distinte (`process` e `inject`) che sono centrali per il funzionamento del tuo motore.

Grazie per il feedback. Riprovo con un piano più raffinato che rispetta e modella esplicitamente questi concetti.

### Filosofia del Nuovo Piano

1.  **Il Trait è Sovrano**: L'interfaccia (`trait`) definisce un contratto, non un tipo di dato. Ogni implementazione del tag sarà libera di definire la propria struttura di stato. Il motore interagirà solo con il contratto, non con i dettagli dello stato.
2.  **Architettura a Due Fasi Esplicita**: Il `trait` rifletterà direttamente la natura a due passaggi del motore: una fase di "elaborazione" (che legge il contesto ed esegue logica esterna) e una fase di "azione" (che dice al motore come modificare il documento).

---

### Piano di Refactoring Rivisto e Dettagliato

#### Fase 1: Definizione del Contratto (`trait Tag`) e dei Tipi di Supporto

Creeremo un nuovo file, `src/execute2/processor.rs`, che sarà il cuore della nostra nuova architettura a plugin.

1.  **Definire `ProcessResult`**: Questa `enum` sarà il risultato della fase di elaborazione e comunicherà al motore l'azione da intraprendere.

    ```rust
    // In src/execute2/processor.rs

    /// L'azione che il motore deve eseguire dopo che un tag ha completato la sua elaborazione.
    pub enum ProcessResult {
        /// Richiede di iniettare il testo fornito nel documento.
        Inject(String),
        /// Il tag ha completato il suo ciclo di vita.
        Completed,
        /// Non è richiesta alcuna azione sul documento.
        NoOp,
        // Potremmo aggiungere altre azioni in futuro, come `ModifyAnchorAttributes(...)`
    }
    ```

2.  **Definire il `trait Tag`**: Questo è il contratto che ogni tag stateful dovrà implementare.

    ```rust
    // In src/execute2/processor.rs
    use std::collections::HashMap;
    use serde::{Serialize, de::DeserializeOwned};

    pub trait Tag: Send + Sync {
        /// Lo stato specifico di questo tag. Ogni implementazione definisce la propria struct.
        /// Deve essere serializzabile per la persistenza.
        type State: Serialize + DeserializeOwned + Default + Send + Sync;

        /// Ritorna il nome univoco del tag (es. "answer").
        fn name(&self) -> &'static str;

        /// Crea lo stato iniziale del tag a partire dagli attributi letti dal documento.
        fn initialize(&self, attributes: &HashMap<String, String>) -> Result<Self::State, anyhow::Error>;

        /// **Fase 1: Elaborazione (Process).**
        /// Esegue la logica principale del tag (es. query a LLM, lettura file).
        /// Prende lo stato corrente e il contesto raccolto, e ritorna un'azione per il motore.
        fn process(&self, state: &mut Self::State, context: &str) -> Result<ProcessResult, anyhow::Error>;
    }
    ```
    **Nota chiave**: Abbiamo un solo metodo, `process`, che però ritorna un `ProcessResult`. Questo mantiene la separazione concettuale: `process` fa il lavoro "esterno", e il suo risultato guida il motore nella fase di modifica del documento, rispettando la tua architettura a due passaggi.

3.  **Creare un Wrapper Type-Erased**: Per poter mettere `Box` di `Tag` diversi in una `HashMap`, dobbiamo cancellare il tipo associato `State`. Creeremo un `trait` interno e un wrapper per gestire questo in modo trasparente.

    ```rust
    // In src/execute2/processor.rs (o un modulo interno)

    // Trait interno che il motore userà. Lavora su dati JSON generici.
    pub trait ErasedTag: Send + Sync {
        fn name(&self) -> &'static str;
        fn initialize_erased(&self, attributes: &HashMap<String, String>) -> Result<serde_json::Value, anyhow::Error>;
        fn process_erased(&self, state: &mut serde_json::Value, context: &str) -> Result<ProcessResult, anyhow::Error>;
    }

    // Implementazione automatica che adatta qualsiasi `Tag` al nostro trait erased.
    impl<T: Tag> ErasedTag for T {
        fn name(&self) -> &'static str { self.name() }

        fn initialize_erased(&self, attributes: &HashMap<String, String>) -> Result<serde_json::Value, anyhow::Error> {
            let state = self.initialize(attributes)?;
            serde_json::to_value(state).map_err(Into::into)
        }

        fn process_erased(&self, state_json: &mut serde_json::Value, context: &str) -> Result<ProcessResult, anyhow::Error> {
            // Deserializza, processa, e riserializza lo stato.
            let mut state: T::State = serde_json::from_value(state_json.clone())?;
            let result = self.process(&mut state, context)?;
            *state_json = serde_json::to_value(state)?;
            Ok(result)
        }
    }
    ```

**Beneficio di questa fase**: Abbiamo un'architettura a plugin robusta e idiomatica in Rust, che non impone una struttura rigida allo stato e rispetta la logica a due fasi.

---

#### Fase 2: Refactoring del Motore (`execute.rs`)

Il motore ora diventa un orchestratore generico che non conosce i dettagli di nessun tag.

1.  **Creare la `TagRegistry`**:

    ```rust
    // In execute.rs o un nuovo modulo `engine.rs`
    use std::collections::HashMap;
    use super::processor::ErasedTag;

    pub struct TagRegistry {
        processors: HashMap<&'static str, Box<dyn ErasedTag>>,
    }

    impl TagRegistry {
        pub fn new() -> Self {
            let mut processors: HashMap<&'static str, Box<dyn ErasedTag>> = HashMap::new();
            
            // Registrazione dei processori (che implementeremo nella Fase 3)
            let answer_proc = Box::new(super::processors::answer::AnswerProcessor);
            processors.insert(answer_proc.name(), answer_proc);
            // ... e così via per gli altri ...

            Self { processors }
        }

        pub fn get(&self, name: &str) -> Option<&dyn ErasedTag> {
            self.processors.get(name).map(|b| b.as_ref())
        }
    }
    ```

2.  **Adattare il Ciclo di Esecuzione**: Il loop principale in `execute.rs` userà la registry. La logica `AnchorStatus` (`JustCreated`, `NeedProcessing`, `NeedInjection`) rimane valida e utile a livello di motore per orchestrare il flusso.

    ```rust
    // Pseudo-codice del nuovo loop in execute.rs

    let registry = TagRegistry::new();

    // Pass 1: Process anchors that need it
    for anchor in find_anchors_with_status(AnchorStatus::NeedProcessing) {
        let processor = registry.get(anchor.tag_name()).unwrap();
        let mut state = load_state_for_anchor(anchor); // Carica il serde_json::Value

        match processor.process_erased(&mut state, anchor.collected_context()) {
            Ok(ProcessResult::Inject(text_to_inject)) => {
                // Salva il risultato per la fase 2
                store_injection_data(anchor, text_to_inject); 
                update_anchor_status(anchor, AnchorStatus::NeedInjection);
            },
            Ok(ProcessResult::Completed) => {
                update_anchor_status(anchor, AnchorStatus::Complete);
            },
            // ... altri casi
        }
        save_state_for_anchor(anchor, state); // Salva lo stato aggiornato
    }

    // Pass 2: Inject content into the document
    for anchor in find_anchors_with_status(AnchorStatus::NeedInjection) {
        let text = get_injection_data(anchor);
        inject_text_into_document_at_anchor(anchor, text);
        update_anchor_status(anchor, AnchorStatus::Complete);
    }
    ```

**Beneficio di questa fase**: Il motore è completamente disaccoppiato dalla logica dei tag. La sua unica responsabilità è orchestrare il flusso di stati (`NeedProcessing` -> `NeedInjection` -> `Complete`) e chiamare il processore corretto al momento giusto.

---

#### Fase 3: Implementazione Concreta dei `Tag`

Ora creiamo i processori specifici, ognuno nel suo file.

1.  **Creare `src/execute2/processors/answer.rs`**:

    ```rust
    // In src/execute2/processors/answer.rs
    use serde::{Serialize, Deserialize};
    use crate::execute2::processor::{Tag, ProcessResult};

    #[derive(Serialize, Deserialize, Default)]
    pub struct AnswerState {
        model: String,
        prompt: String,
        output: Option<String>,
    }

    pub struct AnswerProcessor;

    impl Tag for AnswerProcessor {
        type State = AnswerState;

        fn name(&self) -> &'static str { "answer" }

        fn initialize(&self, attrs: &HashMap<String, String>) -> Result<Self::State, ...> {
            // Logica per estrarre 'model' e 'prompt' da attrs
            Ok(AnswerState { model: ..., prompt: ..., output: None })
        }

        fn process(&self, state: &mut Self::State, context: &str) -> Result<ProcessResult, ...> {
            // QUI va la logica di `answer`:
            // 1. Combina `state.prompt` con `context`.
            // 2. Chiama l'LLM con `state.model`.
            let result = call_llm(context, &state.model)?;
            
            // 3. Salva l'output nello stato per futura referenza.
            state.output = Some(result.clone());

            // 4. Ritorna l'azione per il motore.
            Ok(ProcessResult::Inject(result))
        }
    }
    ```

2.  **Creare implementazioni simili per `Derive`, `Repeat`, etc.**, ognuna con il proprio `State` e la propria logica in `process`.

---

#### Fase 4: Gestione dei Tag Stateless (Flusso C)

Per `include` e `set`, che non hanno un ciclo di vita stateful, l'approccio più pulito e semplice è gestirli come casi speciali nel motore, prima di entrare nella logica dei processori.

```rust
// In execute.rs, all'inizio del ciclo
for tag in find_all_tags() {
    match tag.name() {
        "include" => {
            // Esegui logica di 'include' immediatamente
            continue; // Vai al prossimo tag
        },
        "set" => {
            // Esegui logica di 'set' immediatamente
            continue; // Vai al prossimo tag
        },
        _ => {
            // Questo è un tag stateful, procedi con la logica della registry...
        }
    }
}
```
Questo evita di complicare il `trait Tag` con concetti che non gli appartengono, mantenendolo focalizzato sul suo scopo principale: gestire tag stateful con un ciclo di vita a due fasi.

### Conclusione

Questo piano rivisto è più robusto, flessibile e allineato con le tue osservazioni. Porta a:
*   **Massima Separazione**: Il motore orchestra, i processori eseguono.
*   **Estensibilità Semplice**: Aggiungere un nuovo tag stateful richiede solo di implementare il `trait Tag` e registrarlo, senza toccare il motore.
*   **Stato Flessibile**: Ogni tag definisce il proprio stato, senza forzature.
*   **Architettura Chiara**: La logica a due fasi è un pilastro esplicito del design.

Attendo la tua approvazione su questo nuovo piano per procedere.
<!-- answer-53639206-fb2e-4fcd-b8ae-eda364547da3:end   -->


