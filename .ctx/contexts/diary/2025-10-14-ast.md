@include rules
@include project
@include agent/planner

# 

vedi il nuovo modulo src/ast/mod.rs che dovrebbe sostituire syntax e semantic, e redigi un piano per la sua implementazione
SOLO implementazione del modulo, NON ancora integrazione.

<!-- answer-fdc92f60-a607-46ad-9e31-6ff2e48b6b85:begin -->
Here's a detailed plan for implementing the `src/ast/mod.rs` module, focusing solely on its internal implementation and not its integration with other parts of the project.

### Plan: Implement `src/ast/mod.rs`

1.  **Clean Up Existing `src/ast/mod.rs`:**
    *   **Objective:** Remove unused imports and resolve structural issues to prepare for new implementations.
    *   **Action:**
        *   Remove the `use sha2::digest::typenum::Double;` statement as it's currently unused and likely a leftover.
        *   Remove the duplicate `struct Text` definition.
        *   Correct the duplicate `parse_anchor` function definition. The function intended to parse arguments should be renamed to `parse_arguments` and its return type adjusted to `Result<Arguments, ParsingError>`.

2.  **Define `ParsingError`:**
    *   **Objective:** Create a robust error handling mechanism for parsing failures.
    *   **Action:** Implement a comprehensive `ParsingError` enum or struct. This should leverage `thiserror` for easy error definition and propagation, covering cases like unexpected tokens, invalid syntax, or premature end-of-file.

3.  **Implement `parse_parameters` Function:**
    *   **Objective:** Accurately parse JSON-formatted parameters.
    *   **Action:**
        *   Develop logic to detect and parse JSON objects enclosed in curly braces `{}`.
        *   Handle scenarios where parameters are optional (i.e., no `{}` is present), returning an empty JSON object in such cases.
        *   Precisely calculate and store the `Range` corresponding to the parsed parameters within the document.

4.  **Implement `parse_argument` Function:**
    *   **Objective:** Parse individual arguments, including complex string formats.
    *   **Action:**
        *   Implement parsing for single words or tokens.
        *   Add support for quoted strings (both single `''` and double `""` quotes).
        *   Incorporate logic to handle standard escape sequences within strings (e.g., `\`, `\'`, `\"`, `\n`, `\r`).
        *   Accurately determine and store the `Range` for each parsed argument.

5.  **Implement `parse_arguments` Function:**
    *   **Objective:** Aggregate multiple parsed arguments.
    *   **Action:**
        *   Iteratively call `parse_argument` to collect all arguments on a line.
        *   Define clear termination conditions for argument parsing, such as the end of the line or the closing `}` of a parameter block.
        *   Calculate and store the `Range` encompassing all parsed arguments.

6.  **Implement `parse_tag` Function:**
    *   **Objective:** Parse a complete tag structure.
    *   **Action:**
        *   Parse the tag's opening directive (e.g., `@<command>`).
        *   Utilize the newly implemented `parse_parameters` to extract any associated parameters.
        *   Utilize the newly implemented `parse_arguments` to extract any arguments following the parameters.
        *   Ensure the `Range` for the entire tag, from its opening to the end of its line, is correctly calculated.
        *   Address the `begin.column == 1` assertion: either implement validation for this or remove it if the design allows for tags not starting at the beginning of a line.

7.  **Implement `parse_anchor` Function:**
    *   **Objective:** Parse a complete anchor structure.
    *   **Action:**
        *   Parse the anchor's opening sequence (e.g., `<!-- <command>-<uuid>:<kind>`).
        *   Call `parse_parameters` and `parse_arguments` to extract their respective data.
        *   Parse the anchor's closing sequence (`-->`).
        *   Calculate and store the `Range` for the entire anchor, including its opening and closing markers.
        *   Address the `begin.column == 1` assertion as per the `parse_tag` function.

8.  **Implement `parse_text` Function:**
    *   **Objective:** Parse plain text content between tags and anchors.
    *   **Action:**
        *   Develop logic to identify and extract sequences of characters that do not conform to tag or anchor syntax.
        *   The parsing should continue until the next recognized tag/anchor pattern or the end of the document.
        *   Calculate and store the `Range` for the extracted text segment.

9.  **Refine `parse_node` and `parse_many_nodes`:**
    *   **Objective:** Ensure correct dispatching and aggregation of parsed nodes.
    *   **Action:**
        *   Update `parse_node` to correctly attempt parsing as a tag, then an anchor, and finally as plain text.
        *   Modify `parse_node` to return a well-defined `ParsingError` if no known node type can be parsed from the current position, preventing the "parsing not advanced" issue.
        *   Verify that `parse_many_nodes` correctly iterates through the document, calling `parse_node` and accumulating the resulting `Node` objects, while accurately advancing the parsing position.

10. **Add Unit Tests:**
    *   **Objective:** Ensure the correctness and robustness of the parsing logic.
    *   **Action:** Create a dedicated test module (e.g., `src/ast/mod.rs` with `#[cfg(test)]` or `src/ast/tests.rs`). Write comprehensive unit tests for each parsing function (`parse_tag`, `parse_anchor`, `parse_parameters`, `parse_argument`, `parse_text`, and the main `parse` function) covering:
        *   Valid inputs for each node type.
        *   Edge cases (e.g., empty parameters, no arguments, text at the beginning/end of the document).
        *   Invalid inputs to verify correct error handling.
        *   Complex combinations of tags, anchors, and text.
<!-- answer-fdc92f60-a607-46ad-9e31-6ff2e48b6b85:end -->

Prima di implementare fai una analisi tecnica e scegli gli strumenti da usare, poi aspetta la mia approvazione.

<!-- answer-3120b673-b70b-457a-a790-e28a4fe2cce0:begin -->
Okay, I understand. Before proceeding with the implementation of `src/ast/mod.rs`, I will provide a technical analysis and confirm the tools to be used.

### Technical Analysis for `src/ast/mod.rs` Implementation

The core task is to parse a custom markdown-like syntax that includes directives (tags and anchors) with arguments and JSON-formatted parameters. This requires robust text processing capabilities, error handling, and structured data extraction.

**Parsing Strategy:**

The plan outlines a line-by-line parsing approach, identifying specific patterns for tags, anchors, and plain text. This suggests a combination of regular expressions for pattern matching and manual string manipulation for extracting components.

**Key Parsing Challenges:**

1.  **Pattern Recognition:** Accurately identifying the start and end of tags, anchors, and their various components (command, UUID, kind, arguments, parameters).
2.  **Argument Parsing:** Handling single words, quoted strings (single and double quotes), and escape sequences within strings.
3.  **Parameter Parsing:** Extracting and deserializing JSON objects.
4.  **Range Tracking:** Precisely determining the `Range` (start and end positions) for each parsed element for later use in an AST.
5.  **Error Handling:** Providing clear and informative errors for malformed input.

### Tool Selection

Based on the project's existing dependencies and the nature of the parsing task, the following Rust crates are suitable and will be utilized:

1.  **`regex`:**
    *   **Purpose:** For efficient pattern matching to identify tags (`@<command>`), anchors (`<!-- <command>-<uuid>:<kind>`), and their internal components. Regular expressions are ideal for quickly finding and extracting structured text patterns.
    *   **Rationale:** Already a common and powerful tool for text processing in Rust. It allows for flexible and precise pattern definition, which is crucial for distinguishing between different directive types and their parts.

2.  **`serde_json`:**
    *   **Purpose:** To parse the JSON-formatted parameters embedded within tags and anchors.
    *   **Rationale:** `serde_json` is the de-facto standard for JSON serialization and deserialization in Rust. It provides robust and efficient parsing of JSON strings into Rust data structures, which is essential for handling the `parameters` field.

3.  **`thiserror`:**
    *   **Purpose:** For defining a custom `ParsingError` enum, simplifying error creation and propagation throughout the parsing logic.
    *   **Rationale:** `thiserror` is already used in the `vespe` project and is a best practice for ergonomic error handling in Rust, allowing for clear and concise error definitions.

4.  **Rust Standard Library String Manipulation:**
    *   **Purpose:** For basic string operations such as slicing, trimming, character iteration, and handling escape sequences within parsed arguments.
    *   **Rationale:** These are fundamental operations that complement `regex` and `serde_json` for fine-grained control over text processing.

**Alternative Considerations (and why they are not chosen):**

*   **`nom` (parser combinator library):** While `nom` is excellent for building complex parsers, the current parsing requirements (line-oriented directives, JSON parameters, simple arguments) can be effectively managed with `regex` and manual string processing, which might offer a simpler and more direct implementation given the existing project structure and the specific parsing challenges. Introducing `nom` might add unnecessary complexity for this particular scope.

**Conclusion:**

The combination of `regex` for pattern matching, `serde_json` for JSON parsing, `thiserror` for error handling, and standard library string manipulation provides a robust and idiomatic set of tools for implementing the `src/ast/mod.rs` module as per the detailed plan.

Do you approve this technical analysis and tool selection?
<!-- answer-3120b673-b70b-457a-a790-e28a4fe2cce0:end -->