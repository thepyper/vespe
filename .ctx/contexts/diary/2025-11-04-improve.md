@include project
@include agent/gemini_25_pro_yolo
@include agent/code_improver

Leggi e fai un report riguardo il modulo src/execute2.

<!-- answer-26449155-1e12-48f6-94f8-0b622d1b91ac:begin {}  -->
Okay, I will start by listing the files in the `src/execute2` directory to understand the module's structure.Got it. Now I will read the content of all the files in the `src/execute2` module to begin the analysis.
Here is a full technical review and implementation plan for the `src/execute2` module.

### 1. One-line summary

The `execute2` module implements a powerful but overly complex multi-pass execution engine that suffers from an incomplete state management refactoring, a fragile and inefficient core loop, and several areas of code duplication that hinder maintainability and extensibility.

### 2. Context & assumptions

*   **Context:** The `execute2` module is the core interpreter for a custom templating/scripting language. It parses files, processes special tags (e.g., `@include`, `@answer`, `@repeat`), manages variables, calls an external AI model via a shell command, and can rewrite the source files with the results.
*   **Language/Framework:** This is a Rust project, likely a command-line application.
*   **Assumptions:**
    1.  A major refactoring of state management was started but not completed. The existence of a detailed `state.rs` file, which is commented out and unused, alongside a separate, less robust state implementation in `tag_answer.rs`, strongly suggests this.
    2.  The multi-pass file-rewrite-and-reread loop in `execute.rs` is intentionally designed to handle commands that modify the document structure before other commands are processed.
    3.  The primary goal is correctness and power over raw performance, though the current implementation has significant performance bottlenecks (repeated file I/O and parsing) that could be addressed.

### 3. High-level issues (bulleted)

*   **Incomplete State Refactoring** — Severity: **High**. The core state logic is duplicated and inconsistent between the unused `state.rs` and the active `tag_answer.rs`, creating confusion and maintenance debt.
*   **Complex & Inefficient Execution Loop** — Severity: **High**. The main loop in `Worker::execute` re-reads and re-parses the same file on every pass, leading to poor performance. Its logic, based on boolean flags and multiple `pass` functions, is hard to follow and brittle.
*   **Unclear State Propagation (`Collector`)** — Severity: **Medium**. The `Collector` struct is passed by value (`clone`) extensively, and functions return complex tuples `(bool, Collector, Vec<...>)`, making the data flow awkward and hard to trace. The name `Collector` is also misleading as it represents the entire execution state, not just collected content.
*   **Boilerplate in Command Dispatch** — Severity: **Medium**. The `TagBehaviorDispatch` `match` statements require manual updates for every new command, making the system rigid. The same applies to `update_variables`.
*   **Hardcoded Configuration** — Severity: **Low**. The model provider command is hardcoded in `variables.rs`, making it difficult to configure the application without changing the source code.
*   **Missing Documentation** — Severity: **Low**. Several key functions and structs have `// TODO doc` comments or lack explanations for their complex behavior, increasing the barrier to entry for new developers.

### 4. Detailed findings

#### Location: `src/execute2/mod.rs`, `src/execute2/state.rs`, `src/execute2/tag_answer.rs`

*   **Type:** Design / Bug
*   **Explanation:** The `mod.rs` file explicitly comments out the `state` module. Concurrently, `tag_answer.rs` defines its own local `AnswerStatus` and `AnswerState` structs. The unused `state.rs` defines a more generic `State` trait and a different `AnswerState` with a more robust `AnchorStatus` enum. This is a critical design flaw. The system should have a single, unified way of handling the lifecycle of stateful commands.
*   **Suggested fix(es):**
    1.  **Complete the refactoring:** Remove the local state definitions in `tag_answer.rs` and `tag_repeat.rs`.
    2.  Uncomment and use the `state.rs` module and its `State` trait across all dynamic policies.
    3.  Update `tag_answer::AnswerPolicy` to use `state::AnswerState` and `state::AnchorStatus`.
*   **Risk:** Medium. This is a significant but necessary refactoring. It will touch several files but will unify the design, making it more stable.

#### Location: `src/execute2/execute.rs` (fn `Worker::execute`, `_pass_internal`)

*   **Type:** Performance / Design
*   **Explanation:** The `execute` function contains a loop that can run up to `max_rewrite_steps`. Inside the loop, both `execute_pass` and `collect_pass` call `_pass_internal`, which begins by reading and parsing the context file from disk (`self.file_access.read_file(...)` and `crate::ast2::parse_document(...)`). If a file is 1MB and the loop runs 5 times, this results in 10MB of I/O and 10 expensive parsing operations. The logic is also controlled by a boolean `do_next_pass`, which is a fragile way to manage a state machine.
*   **Suggested fix(es):**
    1.  Refactor the loop to be driven by a more explicit state. Instead of a boolean, have the pass functions return an enum like `PassResult::Completed(Collector)` or `PassResult::RequiresRerun(Collector)`.
    2.  Parse the document *once* at the beginning of the `execute` function. The `execute_pass` can then apply patches to the *in-memory* content string and re-parse only when necessary, before handing off to `collect_pass`.
*   **Risk:** High. This changes the core execution logic but offers significant performance and clarity improvements.

### 5. Concrete changes to implement (handoff-ready)

#### Task 1: (Blocker) Unify State Management

*   **Title:** Complete the state management refactoring using `state.rs`.
*   **Description:** Remove duplicated state definitions and unify all dynamic commands to use the `State` trait and `AnchorStatus` enum from the `state.rs` module.
*   **Affected files:** `src/execute2/mod.rs`, `src/execute2/tag_answer.rs`, `src/execute2/tag_repeat.rs`, `src/execute2/state.rs`.
*   **Patch or diff snippet:**

    **1. Enable `state` module in `src/execute2/mod.rs`:**
    ```diff
    --- a/src/execute2/mod.rs
    +++ b/src/execute2/mod.rs
    @@ -9,7 +9,7 @@
     
     mod content;
     mod execute;
-    //mod state;
+    mod state;
     mod tag_answer;
     mod tag_include;
     mod tag_repeat;
@@ -20,7 +20,7 @@
     mod variables;
     
     use content::*;
-    //use state::*;
+    use state::*;
     use execute::*;
     use tag_answer::*;
     use tag_include::*;
    ```

    **2. Remove local state from `src/execute2/tag_answer.rs` and use the global one:**
    ```diff
    --- a/src/execute2/tag_answer.rs
    +++ b/src/execute2/tag_answer.rs
    @@ -4,23 +4,9 @@
     
     use super::content::ModelContent;
     use super::variables::Variables;
-    use super::execute::{Collector, Worker};
+    use super::execute::{Collector, Worker}; 
+    use super::state::{AnswerState, AnchorStatus, State};
     use super::tags::{DynamicPolicy, DynamicPolicyMonoResult};
     use crate::ast2::{Anchor, Arguments, Parameters, Position, Range, Tag};
     
-    #[derive(Debug, Default, Serialize, Deserialize, PartialEq, Clone)]
-    pub enum AnswerStatus {
-        #[default]
-        JustCreated,
-        Repeat,
-        NeedProcessing,
-        NeedInjection,
-        Completed,
-    }
-    
-    #[derive(Debug, Default, Serialize, Deserialize, Clone)]
-    pub struct AnswerState {
-        pub status: AnswerStatus,
-        pub reply: String,
-    }
-    
     pub struct AnswerPolicy;
     
     impl DynamicPolicy for AnswerPolicy {
    @@ -36,40 +22,40 @@
             state,
             readonly
         );
-        let mut result = DynamicPolicyMonoResult::<Self::State>::new(collector);
-        match state.status {
-            AnswerStatus::JustCreated => {
-                // Prepare the query
-                state.status = AnswerStatus::NeedProcessing;
-                state.reply = String::new();
-                result.new_state = Some(state);
-                result.do_next_pass = true;
-            }
-            AnswerStatus::NeedProcessing => {
-                // Execute the model query
-                let response =
-                    worker.call_model(&local_variables, input)?; // vec![result.collector.context().clone()])?;
-                state.reply = response;
-                state.status = AnswerStatus::NeedInjection;
-                result.new_state = Some(state);
-                result.do_next_pass = true;
-            }
-            AnswerStatus::NeedInjection => {
-                // Inject the reply into the document
-                let output = state.reply.clone();
-                state.status = AnswerStatus::Completed;
-                result.new_state = Some(state);
-                result.new_output = Some(output);
-                result.do_next_pass = true;
-            }
-            AnswerStatus::Completed => {
-                // Nothing to do
-            }
-            AnswerStatus::Repeat => {
-                // Prepare the query
-                state.status = AnswerStatus::NeedProcessing;
-                state.reply = String::new();
-                result.new_state = Some(state);
-                result.new_output = Some(String::new());
-                result.do_next_pass = true;
-            }
-        }
-        Ok(result)
+        let mut result = DynamicPolicyMonoResult::<Self::State>::new(collector); 
+        match state.get_status() { 
+            AnchorStatus::JustCreated => { 
+                // Prepare the query 
+                state.set_status(AnchorStatus::NeedProcessing); 
+                result.new_state = Some(state); 
+                result.do_next_pass = true; 
+            } 
+            AnchorStatus::NeedProcessing => { 
+                // Execute the model query 
+                let response = worker.call_model(&local_variables, input)?; 
+                state.reply = response; 
+                state.set_status(AnchorStatus::NeedInjection); 
+                result.new_state = Some(state); 
+                result.do_next_pass = true; 
+            } 
+            AnchorStatus::NeedInjection => { 
+                // Inject the reply into the document 
+                let output = state.output(); 
+                state.set_status(AnchorStatus::Completed); 
+                result.new_state = Some(state); 
+                result.new_output = Some(output); 
+                result.do_next_pass = true; 
+            } 
+            AnchorStatus::Completed => { 
+                // Nothing to do 
+            } 
+            AnchorStatus::NeedRepeat => { 
+                // Prepare the query 
+                state.set_status(AnchorStatus::NeedProcessing); 
+                state.reply = String::new(); 
+                result.new_state = Some(state); 
+                result.new_output = Some(String::new()); 
+                result.do_next_pass = true; 
+            } 
+        } 
+        Ok(result) 
     }
 }
    ```
*   **Tests to add/modify:** Create a unit test for `AnswerPolicy::mono` that simulates the state transitions from `JustCreated` to `Completed`.

#### Task 2: (High) Simplify and Optimize the Execution Loop

*   **Title:** Refactor `Worker::execute` to be more efficient and readable.
*   **Description:** Introduce a `PassResult` enum to make control flow explicit. Parse the document once per loop iteration instead of on every single pass.
*   **Affected files:** `src/execute2/execute.rs`.
*   **Patch or diff snippet:**

    ```rust
    // In src/execute2/execute.rs, define a new result type
    enum PassResult {
        Completed(Collector),
        RequiresRerun(Collector),
        PatchesApplied(Collector),
    }

    // Refactor the loop in Worker::execute
    pub fn execute(
        &self,
        collector: Collector,
        context_name: &str,
        max_rewrite_steps: usize,
    ) -> Result<Option<Collector>> {
        tracing::debug!("Worker::execute for context: {}", context_name);
        let context_path = self.path_res.resolve_context(context_name)?;

        let mut current_collector = match collector.descent(&context_path) {
            None => {
                tracing::debug!("Context {} already in visit stack, skipping.", context_name);
                return Ok(Some(collector));
            }
            Some(c) => c,
        };

        for i in 1..=max_rewrite_steps {
            let context_content = self.file_access.read_file(&context_path)?;
            let ast = crate::ast2::parse_document(&context_content)?;

            // Execute pass
            let (pass_1_rerun, collector_1, patches) = self.execute_pass(current_collector, &ast)?;
            if !patches.is_empty() {
                let new_content = Self::apply_patches(&context_content, &patches)?;
                self.file_access.write_file(&context_path, &new_content, None)?;
                current_collector = collector_1;
                // Patches were applied, so we must restart the loop
                continue;
            }
            current_collector = collector_1;
            if pass_1_rerun {
                // A tag requested a rerun without patching, restart loop
                continue;
            }

            // If we are here, the document is stable. Do a final collect pass.
            let (pass_2_rerun, final_collector) = self.collect_pass(current_collector, &ast)?;
            if pass_2_rerun {
                 // This indicates a problem, collect_pass shouldn't need a rerun.
                 // We'll continue to the next iteration to be safe.
                 current_collector = final_collector;
                 continue;
            }

            // Stable and collected, we are done.
            return Ok(Some(final_collector));
        }

        Err(anyhow::anyhow!("Execution exceeded max rewrite steps ({}) for context: {}", max_rewrite_steps, context_name))
    }

    // The pass functions would also need to be updated to accept the AST and not read the file.
    // fn execute_pass(&self, collector: Collector, ast: &Document) -> Result<(bool, Collector, Vec<(Range, String)>)> { ... }
    // fn collect_pass(&self, collector: Collector, ast: &Document) -> Result<(bool, Collector)> { ... }
    ```
*   **Backward compatibility notes:** This is a major internal change and should be developed on a feature branch. It does not alter the public API.

### 6. Example patches & snippets

The patches are provided inline in the task list above.

### 7. Testing plan

*   **Unit Tests:**
    *   Add unit tests for each `StaticPolicy` and `DynamicPolicy` implementation in isolation.
    *   Mock the `Worker` and `Collector` to test state transitions. For `AnswerPolicy`, verify that the status correctly moves from `JustCreated` -> `NeedProcessing` -> `NeedInjection` -> `Completed`.
*   **Integration Tests:**
    *   Create a suite of tests for `execute_context` and `collect_context`.
    *   Use a mock `FileAccessor` to provide virtual files and check the output `ModelContent` and any file writes.
    *   **Test Cases:**
        *   A simple context with only text.
        *   A context that uses `@include` to include another.
        *   A test for circular `@include` to ensure it fails gracefully.
        *   A test for `@set` to verify that variables are correctly updated.
        *   A full test of `@answer`, mocking the `agent::shell::shell_call` to return a fixed string, and verifying that the original file is rewritten with an anchor and the final reply.
        *   A test for `@repeat` to ensure it correctly modifies the parent anchor's state.

### 8. Deployment & rollback plan

*   **Deployment:** All changes should be developed on a dedicated feature branch (e.g., `feat/execute2-refactor`). The branch should only be merged into `main` after all existing and new tests are passing and the code has been reviewed.
*   **Rollback:** If issues are discovered after merging, the merge commit should be reverted using `git revert <merge-commit-hash>`.

### 9. Checklist for the implementing agent

*   [ ] Create a new feature branch: `git checkout -b feat/execute2-refactor`.
*   [ ] Apply the changes for **Task 1 (Unify State Management)**.
*   [ ] Ensure the code compiles (`cargo build`).
*   [ ] Add unit tests for the updated `AnswerPolicy`.
*   [ ] Apply the changes for **Task 2 (Simplify Execution Loop)**.
*   [ ] Refactor `execute_pass` and `collect_pass` to no longer read from the filesystem.
*   [ ] Ensure all existing and new tests pass (`cargo test`).
*   [ ] Run `cargo clippy -- -D warnings` and fix all reported issues.
*   [ ] Run `cargo fmt` to ensure consistent formatting.
*   [ ] Submit the pull request for review.

### 10. Open questions / unknowns

*   **Must resolve before change:** What was the intended final design for the `State` trait and its implementers? The proposed plan completes the most likely path, but confirmation would be ideal.
*   **Optional to resolve:** Is the `panic!` in `_pass_internal` when patches are produced during a collect pass the desired behavior, or should it return an `Err`? (The proposed refactoring makes this condition less likely to occur).
<!-- answer-26449155-1e12-48f6-94f8-0b622d1b91ac:end {}  -->

 Sono abbastanza poco d'accordo.
 In particolare:
 1. filesystem-as-a-state: se scrivo e' perche' voglio che i cambiamenti siano stabili. E' facile che una llm call duri parecchio e potrei voler
    interrompere il programma. Se non scrivo ogni volta, perdo lo stato, che per me e' inaccettabile, anche perche' i files txt sono piccoli e le performance
    sufficienti (99.99% del tempo e' llm che risponde).

 2. state.rs vs tag_xxx.rs: volutamente ho eliminato uno status centrale, e implementato lo Status per ogni tag che puo' avere un proprio status particolare.
    uno dei pochi refactoring buoni e' stato questo: scrivere un file per tag, ed avere tutta la logica del tag contenuta in una unica funzione (mono per i
    dinamici, collect_static_tag per gli statici).

 3. eseguire il patching in-memory non porta molti vantaggi, comunque dovrei rifare il parsing da zero ogni volta, perche' non vorrei certo cambiare
    il documento e la AST. quindi la AST e' disposable, una volta usata si butta via e si rifa se si rilegge il file.

Alla luce di questi commenti, rifai il report.

<!-- answer-5430ea0f-71be-46ba-bc0d-f3aa9b214a27:begin {}  -->
Alla luce dei suoi chiarimenti, ho rivisto la mia analisi. Comprendo ora che la persistenza dello stato sul filesystem ("filesystem-as-a-state") e la gestione decentralizzata dello stato per ogni tag sono scelte di design deliberate e fondamentali, mirate a garantire robustezza e la capacità di riprendere esecuzioni interrotte. Il mio precedente report si basava su un'errata interpretazione di questi principi.

Ecco una nuova analisi che rispetta e costruisce su questa filosofia di progettazione.

### 1. One-line summary

Il modulo `execute2`, pur essendo robusto grazie al suo design stateful basato su filesystem, può essere reso più chiaro, manutenibile ed estensibile migliorando il meccanismo di propagazione dello stato (`Collector`) e disaccoppiando la logica di dispatch dei tag.

### 2. Context & assumptions

*   **Contesto:** Il modulo `execute2` è un interprete per un linguaggio di scripting che orchestra chiamate a modelli esterni (LLM), gestisce un sistema di variabili e template, e processa tag specializzati.
*   **Filosofia di Design:**
    1.  **Stateful Filesystem:** Il sistema usa intenzionalmente il filesystem come unica fonte di verità per lo stato. Ogni modifica significativa viene scritta su disco per garantire la durabilità e la ripresa in caso di interruzioni. Le performance di I/O sono considerate trascurabili rispetto al tempo di attesa delle chiamate LLM.
    2.  **Logica per-Tag Encapsulata:** La logica e lo stato di ogni tag (es. `@answer`, `@repeat`) sono volutamente isolati nel proprio file/modulo. Un approccio con uno stato centralizzato è stato scartato a favore di questa maggiore modularità.
    3.  **AST Monouso:** L'Abstract Syntax Tree (AST) viene generato, utilizzato per un singolo passaggio e poi scartato. Ad ogni ciclo di riscrittura del file, l'AST viene rigenerato da zero.

### 3. High-level issues (bulleted)

*   **Propagazione dello Stato Confusa (`Collector`)** — Severità: **Medium**. La struct `Collector` viene propagata tramite `clone` e restituita in tuple complesse, rendendo il flusso dati difficile da seguire e inefficiente. Il suo nome, inoltre, non descrive accuratamente il suo ruolo di contesto di esecuzione globale.
*   **Dispatch dei Tag Rigido e Ripetitivo** — Severità: **Medium**. I `match` in `TagBehaviorDispatch` e `update_variables` creano un forte accoppiamento e richiedono modifiche manuali in più punti per aggiungere un nuovo tag, rendendo il sistema fragile ed error-prone.
*   **Duplicazione nella Gestione delle Variabili** — Severità: **Low**. La logica per estrarre e risolvere le variabili locali di un tag è duplicata tra `collect_static_tag` e `mono` nelle policy dinamiche.
*   **Configurazione Hardcoded** — Severità: **Low**. Il comando per l'agente del modello è hardcoded, limitando la flessibilità di configurazione dell'applicazione.

### 4. Detailed findings

#### Location: `src/execute2/execute.rs`, `src/execute2/tags.rs`, e tutti i file di policy (`tag_*.rs`)

*   **Type:** Design / Style / Performance
*   **Explanation:** La struct `Collector` agisce come contenitore per l'intero stato dell'esecuzione (variabili globali, stack di visite, ecc.). Viene passata per valore (`clone`) a quasi ogni funzione e restituita in tuple come `(bool, Collector, Vec<...>)`. Questo pattern, comune in approcci funzionali, in Rust è spesso meno idiomatico e performante rispetto all'uso di riferimenti mutabili. Rende difficile capire quale parte del codice modifica lo stato e introduce cloni superflui.
*   **Suggested fix(es):**
    1.  **Rinominare `Collector`:** Cambiare il nome in `ExecutionContext` per riflettere meglio il suo ruolo.
    2.  **Usare Riferimenti Mutabili:** Modificare le funzioni chiave (es. `_pass_internal`, `collect_static_tag`, `mono`) affinché accettino `&mut ExecutionContext` invece di `Collector`. Questo elimina la necessità di clonare e restituire lo stato, rendendo le mutazioni esplicite e il codice più leggibile e performante.
*   **Risk:** Medium. Richiede una modifica coordinata delle firme di molte funzioni, ma non altera la logica di business. Il compilatore di Rust guiderà gran parte del refactoring.

#### Location: `src/execute2/tags.rs` (enum `TagBehaviorDispatch`), `src/execute2/execute.rs` (fn `update_variables`)

*   **Type:** Design / Anti-pattern
*   **Explanation:** Per aggiungere un nuovo tag, uno sviluppatore deve modificare l'enum `TagBehaviorDispatch` e almeno due grossi `match`: uno per il dispatch statico/dinamico e uno in `update_variables` per la gestione delle variabili. Questo viola il principio Open/Closed.
*   **Suggested fix(es):**
    1.  **Introdurre un `TagProcessor` Trait:** Creare un trait `TagProcessor` con metodi come `process_static`, `process_dynamic`, e `get_local_variables`.
    2.  **Dispatch basato su `HashMap`:** Rimpiazzare i `match` con una `HashMap<String, Box<dyn TagProcessor>>`. All'avvio, la mappa viene popolata con le implementazioni per ogni tag. Il loop di esecuzione cerca semplicemente il nome del tag nella mappa e chiama il metodo appropriato. L'aggiunta di un nuovo tag consisterebbe solo nel creare un nuovo file che implementa il trait e registrarlo nella mappa, senza modificare il codice esistente.
*   **Risk:** Low. È un refactoring di disaccoppiamento classico che migliora notevolmente l'estensibilità.

### 5. Concrete changes to implement (handoff-ready)

#### Task 1: (High) Refactor `Collector` to `ExecutionContext` using Mutable Borrows

*   **Title:** Refactor state propagation to use mutable references.
*   **Description:** Rename `Collector` to `ExecutionContext` and change function signatures to pass it as `&mut self` or `&mut context`, eliminating clones and complex return tuples.
*   **Affected files:** `execute.rs`, `tags.rs`, `tag_answer.rs`, `tag_include.rs`, `tag_repeat.rs`, `tag_set.rs`.
*   **Patch or diff snippet (Example for `_pass_internal`):**

    ```diff
    --- a/src/execute2/execute.rs
    +++ b/src/execute2/execute.rs
    @@ -138,14 +138,14 @@
         &self,
         collector: Collector,
         ast: &Document,
-        is_collect_pass: bool,
     ) -> Result<(bool, Collector, Vec<(Range, String)>)> {
-        let mut do_next_pass = false;
-        let mut current_collector = collector;
+        // NOTE: This function now mutates the collector directly.
+        // The return value is (do_next_pass, patches)
+    fn _pass_internal(
+        &self,
+        collector: &mut Collector, // To be renamed ExecutionContext
+        ast: &Document,
+        is_collect_pass: bool,
+    ) -> Result<(bool, Vec<(Range, String)>)> {
+        let mut do_next_pass = false;
         let mut patches = Vec::new();
     
         for element in &ast.elements {
    @@ -153,11 +153,11 @@
                 TagElement::Tag(tag) => {
                     if is_collect_pass {
-                        let (rerun, next_collector) = self.collect_static_tag(current_collector, tag)?;
-                        current_collector = next_collector;
+                        let (rerun, _) = self.collect_static_tag(collector, tag)?;
                         do_next_pass |= rerun;
                     } else {
-                        let (rerun, next_collector, new_patches) =
-                            self.execute_dynamic_tag(current_collector, tag)?;
-                        current_collector = next_collector;
+                        let (rerun, new_patches) =
+                            self.execute_dynamic_tag(collector, tag)?;
                         patches.extend(new_patches);
                         do_next_pass |= rerun;
                     }
    @@ -166,7 +166,7 @@
             }
         }
     
-        Ok((do_next_pass, current_collector, patches))
+        Ok((do_next_pass, patches))
     }
     
     // The calling functions execute_pass and collect_pass would be updated accordingly:
     // let (pass_1_rerun, patches) = self.execute_pass(&mut current_collector, &ast)?;
     // let (pass_2_rerun, _) = self.collect_pass(&mut final_collector, &ast)?;
    ```

*   **Tests to add/modify:** I test esistenti dovrebbero essere adattati alle nuove firme. Non sono necessari nuovi test di logica, poiché questa non cambia.

#### Task 2: (Medium) Decouple Tag Dispatching

*   **Title:** Introduce a `TagProcessor` trait to make tag dispatch extensible.
*   **Description:** Replace the rigid `match` statements for tag handling with a `HashMap` lookup of trait objects.
*   **Affected files:** `tags.rs`, `execute.rs`.
*   **Patch or diff snippet:**

    ```rust
    // In a new file, e.g., src/execute2/processor.rs
    pub trait TagProcessor: Send + Sync {
        // Handles dynamic tags during the execute pass
        fn process_dynamic(&self, context: &mut ExecutionContext, tag: &Tag) -> Result<(bool, Vec<(Range, String)>)>;
        
        // Handles static tags during the collect pass
        fn process_static(&self, context: &mut ExecutionContext, tag: &Tag) -> Result<(bool, Option<ModelContent>)>;
    }

    // In execute.rs, the Worker would have a map
    pub struct Worker {
        // ... other fields
        processors: HashMap<String, Box<dyn TagProcessor>>,
    }

    impl Worker {
        pub fn new(...) -> Self {
            let mut processors: HashMap<String, Box<dyn TagProcessor>> = HashMap::new();
            processors.insert("@answer".to_string(), Box::new(AnswerPolicy));
            processors.insert("@include".to_string(), Box::new(IncludePolicy));
            // ... register all other policies
            
            Worker { processors, ... }
        }

        // The dispatch logic becomes:
        fn dispatch_tag(&self, context: &mut ExecutionContext, tag: &Tag, is_collect_pass: bool) -> ... {
            if let Some(processor) = self.processors.get(tag.name.as_str()) {
                if is_collect_pass {
                    processor.process_static(context, tag)
                } else {
                    processor.process_dynamic(context, tag)
                }
            } else {
                // Handle unknown tag
                Ok((false, None)) 
            }
        }
    }
    ```

*   **Tests to add/modify:** Aggiungere un test che verifichi il corretto funzionamento del dispatch tramite la mappa, includendo un caso per un tag sconosciuto.

### 6. Testing plan

*   **Unit Tests:** Mantenere i test esistenti, adattandoli alle nuove firme delle funzioni (`&mut ExecutionContext`).
*   **Integration Tests:** I test di integrazione esistenti sono già validi per verificare che il comportamento end-to-end non sia cambiato. Aggiungere un caso di test con un file di contesto che usa un tag non registrato nel processore per assicurarsi che venga ignorato silenziosamente.

### 7. Deployment & rollback plan

*   **Deployment:** Le modifiche dovrebbero essere sviluppate su un branch separato. Il Task 1 (refactoring di `Collector`) dovrebbe essere completato e testato prima di iniziare il Task 2.
*   **Rollback:** Data la natura del refactoring, il modo più sicuro per fare rollback è revertire il merge commit da Git.

### 8. Checklist for the implementing agent

*   [ ] Creare un branch `refactor/execution-context`.
*   [ ] Eseguire il Task 1: rinominare `Collector` in `ExecutionContext` e aggiornare tutte le firme delle funzioni per usare `&mut ExecutionContext`.
*   [ ] Verificare che il progetto compili e che i test passino dopo il Task 1.
*   [ ] Eseguire il Task 2: introdurre il trait `TagProcessor` e sostituire i `match` con il dispatch basato su `HashMap`.
*   [ ] Aggiungere i test per il nuovo sistema di dispatch.
*   [ ] Eseguire `cargo test --all-targets` per assicurarsi che nulla sia stato rotto.
*   [ ] Eseguire `cargo clippy -- -D warnings` e `cargo fmt`.
*   [ ] Aprire una Pull Request per la revisione.

### 9. Open questions / unknowns

*   Nessuna questione bloccante. Il piano è autoconsistente e rispetta i principi di design forniti.
<!-- answer-5430ea0f-71be-46ba-bc0d-f3aa9b214a27:end {}  -->

