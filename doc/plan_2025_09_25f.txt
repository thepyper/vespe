# Piano di Refactoring API per il Ciclo di Vita del Task

Questo piano delinea i passaggi dettagliati per migrare l'API esistente del crate `vespe` (principalmente `src/task.rs` e `src/project.rs`) al nuovo design del ciclo di vita del task definito in `doc/design_2025_09_25d.txt`.

## FASE 0: Preparazione e Definizione Nuovi Tipi

1.  **Aggiornare `vespe/src/task.rs`:**
    *   **Modificare `TaskState` enum:**
        *   Rimuovere `Created`, `ObjectiveDefined`, `PlanDefined`, `Executing`, `WaitingForSubtasks`, `NeedsReview`, `Completed`, `Failed`, `Aborted`, `Replanned`.
        *   Aggiungere i nuovi stati (in CamelCase): `Created`, `ObjectiveDefined`, `PlanDefined`, `Delegating`, `Harvesting`, `Working`, `Error`, `Failed`, `Completed`.
        *   Aggiungere `#[derive(Debug, PartialEq, Eq, Clone, Copy, Serialize, Deserialize)]` all'enum.
    *   **Definire `TaskType` enum:**
        *   Aggiungere `enum TaskType { Monolithic, Subdivided }`.
    *   **Modificare `TaskConfig` struct:**
        *   Aggiungere `task_type: Option<TaskType>` (sarà `None` fino a `PlanDefined`).
    *   **Modificare `TaskStatus` struct:**
        *   Aggiungere `is_paused: bool`.
        *   Aggiungere `error_details: Option<String>`.
        *   Aggiungere `previous_state: Option<TaskState>` (per il recupero da `Error`).
        *   Aggiungere `retry_count: u8` (per `Error`).
    *   **Modificare `Task` struct:**
        *   Rimuovere i metodi `define_objective`, `define_plan`, `update`, `review_task`.
        *   Aggiungere un campo `subtasks: HashMap<String, TaskState>` per tenere traccia dei sub-task (lo stato del sub-task sarà il suo `TaskState`).

2.  **Aggiornare `vespe/src/error.rs`:**
    *   Aggiungere nuovi varianti a `ProjectError` per gestire errori specifici delle nuove transizioni di stato (es. `InvalidStateTransition`, `TaskNotFound`, `SubtaskNotFound`).

## FASE 1: Implementazione del Trait `TaskLifecycle` su `Project`

1.  **Creare il trait `TaskLifecycle` in `vespe/src/project.rs` (o un nuovo file `vespe/src/task_manager.rs`):**
    *   Definire il trait `TaskLifecycle` esattamente come specificato nel design `doc/design_2025_09_25d.txt`, ma senza `subtask_terminated`.
    *   Per ora, implementeremo questo trait direttamente sulla struct `Project`. Se la logica diventa troppo complessa, potremmo estrarre un `TaskManager` separato.

2.  **Implementare `TaskLifecycle` per `Project` in `vespe/src/project.rs`:**
    *   **`define_objective(&mut self, task_id: &str, objective_content: String)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da `Created` o `ObjectiveDefined` a `ObjectiveDefined`).
        *   Aggiornare `task.objective` e salvare `objective.md`.
        *   Aggiornare `task.status.current_state` a `ObjectiveDefined` e salvare `status.json`.
    *   **`define_plan(&mut self, task_id: &str, plan_content: String, task_type: TaskType)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da `ObjectiveDefined` o `PlanDefined` a `PlanDefined`).
        *   Aggiornare `task.plan` e salvare `plan.md`.
        *   Aggiornare `task.config.task_type` e salvare `config.json`.
        *   Aggiornare `task.status.current_state` a `PlanDefined` e salvare `status.json`.
    *   **`accept_plan(&mut self, task_id: &str)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da `PlanDefined`).
        *   Basandosi su `task.config.task_type`:
            *   Se `Monolithic` -> Aggiornare `task.status.current_state` a `Working`.
            *   Se `Subdivided` -> Aggiornare `task.status.current_state` a `Delegating`.
        *   Salvare `status.json`.
    *   **`reject_plan(&mut self, task_id: &str)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da `PlanDefined`).
        *   Aggiornare `task.status.current_state` a `ObjectiveDefined`.
        *   Salvare `status.json`.
    *   **`add_subtask(&mut self, task_id: &str, subtask_id: &str, is_final: bool)`:**
        *   Caricare il task genitore.
        *   Validare la transizione di stato (da `Delegating`).
        *   Aggiungere `subtask_id` alla mappa `task.subtasks` con stato iniziale (es. `Created`).
        *   Se `is_final == true` -> Aggiornare `task.status.current_state` a `Harvesting`.
        *   Salvare `config.json` (se `subtasks` è parte di `config`) e `status.json` (se `subtasks` è parte di `status`).
    *   **`error(&mut self, task_id: &str, details: String, is_failure: bool)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da qualsiasi stato tranne `Failed`, `Completed`).
        *   Salvare `task.status.previous_state` prima di cambiare stato.
        *   Se `is_failure == true` -> Aggiornare `task.status.current_state` a `Failed`.
        *   Se `is_failure == false` -> Aggiornare `task.status.current_state` a `Error`.
        *   Aggiornare `task.status.error_details`.
        *   Salvare `status.json`.
    *   **`work_completed(&mut self, task_id: &str)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da `Working`).
        *   Aggiornare `task.status.current_state` a `Completed`.
        *   Salvare `status.json`.
    *   **`abort(&mut self, task_id: &str, reason: String)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da qualsiasi stato tranne `Failed`, `Completed`).
        *   Aggiornare `task.status.current_state` a `Failed`.
        *   Aggiornare `task.status.error_details` con la ragione dell'aborto.
        *   **Implementare aborto a cascata:** Identificare e chiamare `abort()` su tutti i sub-task attivi.
        *   Salvare `status.json`.
    *   **`pause_task(&mut self, task_id: &str, reason: String)`:**
        *   Caricare il task.
        *   Impostare `task.status.is_paused = true`.
        *   Salvare `status.json`.
    *   **`resume_task(&mut self, task_id: &str)`:**
        *   Caricare il task.
        *   Impostare `task.status.is_paused = false`.
        *   Salvare `status.json`.
    *   **`get_task_state(&self, task_id: &str)`:**
        *   Caricare il task e restituire `task.status.current_state`.
    *   **`is_task_paused(&self, task_id: &str)`:**
        *   Caricare il task e restituire `task.status.is_paused`.
    *   **(Rimosso) `subtask_terminated(&mut self, parent_task_id: &str, subtask_id: &str, status: SubtaskStatus)`:**
        *   La logica di valutazione del genitore sarà gestita dalle chiamate `work_completed` o `error` sui sub-task stessi.

## FASE 2: Aggiornamento delle Funzioni Esistenti in `Project`

1.  **Modificare `Project::create_task`:**
    *   La funzione creerà il task nello stato `Created`.
    *   Non imposterà più `objective.md` vuoto, ma lo lascerà alla `define_objective`.
2.  **Rimuovere `Project::define_objective`:** La logica sarà gestita dal trait `TaskLifecycle`.
3.  **Rimuovere `Project::define_plan`:** La logica sarà gestita dal trait `TaskLifecycle`.
4.  **Rimuovere `Project::update_task`:** La logica sarà gestita dal trait `TaskLifecycle` (tramite `define_objective` e `define_plan`).
5.  **Rimuovere `Project::create_and_define_task`:** La logica sarà gestita da `create_task` seguito da `define_objective`.

## FASE 3: Aggiornamento dell'Interfaccia Utente (vespe-tui)

1.  **Modificare `vespe-tui/src/pages/task_edit.rs`:**
    *   Aggiornare le chiamate API per `F5` (Cancel) e `F6` (Save) per usare i nuovi metodi del trait `TaskLifecycle` su `app.project`.
    *   La logica di creazione/aggiornamento dovrà essere adattata per chiamare `define_objective` e `define_plan` separatamente.
    *   La logica di `abort` dovrà usare la nuova API `abort()`.

2.  **Modificare `vespe-tui/src/pages/tasks.rs`:**
    *   Aggiornare le chiamate API per la creazione di nuovi task (F5) per usare `Project::create_task` e poi `define_objective`.
    *   Aggiornare le chiamate API per l'ispezione/modifica di task esistenti (F6).

## FASE 4: Pulizia e Test

1.  **Rimuovere codice obsoleto:** Eliminare tutte le vecchie funzioni e i campi non più utilizzati.
2.  **Eseguire `cargo check` e `cargo build`:** Verificare la compilazione.
3.  **Test manuali:** Eseguire il TUI e verificare che tutte le funzionalità di creazione, modifica, salvataggio, annullamento, ispezione e navigazione dei task funzionino come previsto.

---

**Dubbi/Considerazioni per il Piano:**

*   **`TaskState` e Dati Associati:** La proposta di arricchire l'enum `TaskState` con dati associati (es. `Error(details: String, previous_state: TaskState)`) è molto potente. Questo influenzerà direttamente la definizione dell'enum in `src/task.rs` e come i dati vengono salvati/caricati. L'implementazione dovrà considerare questi dati.
*   **`TaskType` Storage:** Il `task_type` (Monolithic/Subdivided) deve essere persistito. La proposta è di aggiungerlo a `TaskConfig`.
*   **`retry()` e `replan_from_error()`:** Queste API sono state rimosse dal design per ora. Il piano non le implementerà in questa fase.
*   **`abort()` Cascading:** L'implementazione dell'aborto a cascata richiederà di caricare i sub-task e chiamare `abort()` su di essi. Questo implica che `abort()` deve essere ricorsivo o iterativo.
*   **Interazione Agenti/Utente:** Le API saranno a disposizione sia dell'utente che degli agenti. L'utente è considerato un "agente in carne ed ossa".
*   **Persistenza:** La persistenza dello stato del task è garantita dalla struttura `Task` esistente, che salva i dati su filesystem.
*   **Concurrency:** Per ora, l'implementazione sarà single-threaded. La gestione della concorrenza sarà considerata in futuro se necessario.
*   **Nomenclatura:** La nomenclatura degli stati e delle transizioni seguirà le convenzioni idiomatiche di Rust (CamelCase per gli enum variants).
