### Fase 2: Separazione dei File delle Policy

Questa fase si concentra sulla creazione di file separati per ciascuna policy e sulla pulizia del file originale.

#### 2.1. Creazione del File `src/llm/impls/json_policy.rs`

*   **Azione**: Creare un nuovo file `src/llm/impls/json_policy.rs`.
*   **Contenuto**: Copiare la struct `JsonMarkdownPolicy` e i suoi blocchi `impl` (giÃ  modificati nella Fase 1) da `various_markdown_policy.rs`.
*   **Rinominare**: Rinominare `JsonMarkdownPolicy` in `JsonPolicy`.
*   **Implementare `get_policy_type`**:
    ```rust
    // src/llm/impls/json_policy.rs
    use anyhow::Result;
    use regex::Regex;
    use serde_json;

    use crate::llm::markdown_policy::{MarkdownPolicy};
    use crate::llm::messages::{Message, AssistantContent, ToolCall};
    use crate::llm::policy_types::PolicyType;
    use crate::llm::tool_types::ToolType;
    use crate::llm::tool_output_formatters; // Importa il nuovo modulo
    use llm::chat::{ChatMessage as LlmChatMessage, ChatRole, MessageType};

    pub struct JsonPolicy;

    impl JsonPolicy {
        pub fn new() -> Self { Self {} }

        // format_tool_output (copiato e modificato dalla Fase 1.3)
        fn format_tool_output(tool_output: &crate::llm::messages::ToolOutput, policy_type: PolicyType) -> Result<String> {
            let tool_type = ToolType::from(tool_output.tool_name.as_str());
            let formatted_result = tool_output_formatters::format_tool_output(tool_type, &tool_output.output, policy_type)?;

            Ok(format!(
                "```tool_result\n{{\n  \"tool\": \"{}\",\n  \"call_id\": \"{}\",\n  \"result\": {}\n}}\n```",
                tool_output.tool_name,
                tool_output.call_id.as_deref().unwrap_or("unknown"),
                formatted_result
            ))
        }
    }

    impl MarkdownPolicy for JsonPolicy {
        fn markdown_format_instructions(&self) -> String {
            r###"RESPONSE FORMAT REQUIREMENTS:

You MUST structure your response using these EXACT formats:

1. TOOL CALLS - Use this format when calling tools:
```tool_call
{
  "name": "tool_name",
  "arguments": {
    "param1": "value1",
    "param2": "value2"
  }
}
```

2. INTERNAL REASONING - Use this format for your thinking process:
```reasoning
{
  "thoughts": "Step-by-step analysis of what I need to do and why",
  "approach": "My strategy for solving this problem"
}
```

3. CODE BLOCKS - Use standard markdown for code:
```python
# Your code here
def example():
    return "hello"
```

4. PLAIN TEXT - Use normal text for responses to the user.

IMPORTANT RULES:
- Each JSON block must be valid JSON
- Do not nest code blocks
- Separate different types of content clearly
- Tool calls and reasoning blocks are processed specially

Example response structure:
```reasoning
{
  "thoughts": "I need to search for information about X",
  "approach": "I'll use the web search tool first"
}
```

```tool_call
{
  "name": "web_search", 
  "arguments": {"query": "example search"}
}
```

Based on the search results, here's what I found...

```python
def solution():
    return "implementation"
```

This code demonstrates the solution because..."###.to_string()
        }

        fn parse_response(&self, response: &str) -> Result<Vec<AssistantContent>> {
            let mut parsed_content = Vec::new();
            let mut last_index = 0;

            // Combined regex to find all structured blocks in order
            let combined_re = Regex::new(
                r"```(tool_call|reasoning)\n([\s\S]*?)\n```"
            )?;

            for mat in combined_re.find_iter(response) {
                let start = mat.start();
                let end = mat.end();

                // Add any preceding plain text
                if start > last_index {
                    let text = response[last_index..start].trim();
                    if !text.is_empty() {
                        parsed_content.push(AssistantContent::Text(text.to_string()));
                    }
                }

                // Extract block type and content
                let full_match = mat.as_str();
                let captures = combined_re.captures(full_match).unwrap();
                let block_type = captures.get(1).unwrap().as_str();
                let json_content = captures.get(2).unwrap().as_str();

                match block_type {
                    "tool_call" => {
                        let tool_call: ToolCall = serde_json::from_str(json_content)
                            .map_err(|e| anyhow::anyhow!("Invalid tool_call JSON: {} in: {}", e, json_content))?;
                        parsed_content.push(AssistantContent::ToolCall(tool_call));
                    }
                    "reasoning" => {
                        #[derive(serde::Deserialize)]
                        struct ReasoningBlock {
                            thoughts: String,
                            #[serde(default)]
                            approach: String,
                        }

                        let reasoning: ReasoningBlock = serde_json::from_str(json_content)
                            .map_err(|e| anyhow::anyhow!("Invalid reasoning JSON: {} in: {}", e, json_content))?;

                        let combined_thought = if reasoning.approach.is_empty() {
                            reasoning.thoughts
                        } else {
                            format!("{}\nApproach: {}", reasoning.thoughts, reasoning.approach)
                        };
                        parsed_content.push(AssistantContent::Thought(combined_thought));
                    }
                    _ => {} // Should not happen with the current regex
                }

                last_index = end;
            }

            // Add any remaining plain text
            if last_index < response.len() {
                let text = response[last_index..].trim();
                if !text.is_empty() {
                    parsed_content.push(AssistantContent::Text(text.to_string()));
                }
            }

            // Fallback: if no structured content found, treat as plain text
            if parsed_content.is_empty() && !response.trim().is_empty() {
                parsed_content.push(AssistantContent::Text(response.to_string()));
            }

            Ok(parsed_content)
        }

        fn format_query(&self, messages: &[Message]) -> Result<Vec<LlmChatMessage>> {
            let mut llm_chat_messages = Vec::new();
            let policy_type = self.get_policy_type(); // Ottieni il tipo di policy una volta

            for msg in messages {
                match msg {
                    Message::System(content) => {
                        llm_chat_messages.push(LlmChatMessage {
                            role: ChatRole::User,
                            content: content.clone(),
                            message_type: MessageType::Text,
                        });
                    },
                    Message::User(content) => {
                        llm_chat_messages.push(LlmChatMessage {
                            role: ChatRole::User,
                            content: content.clone(),
                            message_type: MessageType::Text,
                        });
                    },
                    Message::Assistant(content_parts) => {
                        let mut assistant_content = String::new();

                        for part in content_parts {
                            match part {
                                AssistantContent::Text(text) => {
                                    assistant_content.push_str(text);
                                    assistant_content.push('\n');
                                },
                                AssistantContent::Thought(thought) => {
                                    assistant_content.push_str(&format!(
                                        "```reasoning\n{{\n  \"thoughts\": \"{}\"\n}}\n```\n",
                                        thought.replace('"', "\\\"")
                                    ));
                                },
                                AssistantContent::ToolCall(tool_call) => {
                                    assistant_content.push_str(&format!(
                                        "```tool_call\n{{\n  \"name\": \"{}\",\n  \"arguments\": {}\n}}\n```\n",
                                        tool_call.name,
                                        serde_json::to_string_pretty(&tool_call.arguments)?
                                    ));
                                },
                            }
                        }

                        llm_chat_messages.push(LlmChatMessage {
                            role: ChatRole::Assistant,
                            content: assistant_content.trim().to_string(),
                            message_type: MessageType::Text,
                        });
                    },
                    Message::Tool(tool_output) => {
                        let formatted_output = Self::format_tool_output(tool_output, policy_type)?;
                        llm_chat_messages.push(LlmChatMessage {
                            role: ChatRole::User,
                            content: formatted_output,
                            message_type: MessageType::Text,
                        });
                    },
                }
            }
            Ok(llm_chat_messages)
        }

        fn get_policy_type(&self) -> PolicyType { PolicyType::Json } // Implementazione
    }
    ```
*   **Motivazione**: Separa la policy JSON nel suo file dedicato.

**CONTINUA NEL FILE: `doc/plan_2025_09_17n_09_phase2_xml_policy.txt`**
