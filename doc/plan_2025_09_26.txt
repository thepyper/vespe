# Piano di Refactoring: Gestione Task e Subtask

**Data:** 26 Settembre 2025
**Basato su:** `doc/design_2025_09_26.txt`

## 1. Obiettivo del Piano

Questo piano delinea i passaggi necessari per implementare le modifiche al sistema di gestione dei task e dei subtask, come descritto nel documento di design `doc/design_2025_09_26.txt`. L'obiettivo è semplificare la logica dei task, eliminare la distinzione monolitico/suddiviso e integrare la gestione dei subtask tramite il flag `is_paused`.

## 2. Fasi del Refactoring

### Fase 0: Preparazione e Pulizia Iniziale

**Obiettivo:** Rimuovere gli stati e i tipi di task obsoleti per semplificare la base di codice.

1.  **Backup:** Assicurarsi di avere un backup del progetto prima di iniziare le modifiche.
2.  **Modifica `TaskState` Enum:**
    *   **File:** `src/task.rs`
    *   **Azione:** Rimuovere i membri `Delegating`, `Harvesting` e `Replanned` dall'enum `TaskState`.
    *   **Verifica:** Compilare il progetto per identificare e risolvere eventuali riferimenti a questi stati rimossi. Questo potrebbe richiedere modifiche temporanee in altre parti del codice che usano `TaskState`.
3.  **Modifica `TaskType` Enum:**
    *   **File:** `src/task.rs`
    *   **Azione:** Rimuovere l'enum `TaskType` (`Monolithic`, `Subdivided`) e tutti i suoi riferimenti.
    *   **Verifica:** Compilare il progetto per identificare e risolvere eventuali riferimenti a `TaskType`.
4.  **Modifica `TaskConfig` Struct:**
    *   **File:** `src/task.rs`
    *   **Azione:** Rimuovere il campo `pub task_type: Option<TaskType>` dalla struct `TaskConfig`.
    *   **Verifica:** Compilare il progetto per identificare e risolvere eventuali riferimenti a `task_type` in `TaskConfig`.

### Fase 1: Aggiornamento delle Strutture Dati `Task` e `TaskStatus`

**Obiettivo:** Introdurre i nuovi campi necessari per la gestione dei subtask e la logica di pausa.

1.  **Verifica `TaskStatus`:**
    *   **File:** `src/task.rs`
    *   **Azione:** Assicurarsi che i campi `pub is_paused: bool` e `pub previous_state: Option<TaskState>` siano presenti nella struct `TaskStatus`. Se mancanti, aggiungerli con valori predefiniti (`false` e `None`).
2.  **Aggiunta `subtask_uids` a `Task`:**
    *   **File:** `src/task.rs`
    *   **Azione:** Aggiungere il campo `pub subtask_uids: Vec<String>` alla struct `Task`.

### Fase 2: Aggiornamento delle Funzioni di Creazione e Caricamento dei Task

**Obiettivo:** Adattare le funzioni che creano e caricano i task per gestire i nuovi campi.

1.  **Modifica `Project::create_task`:**
    *   **File:** `src/project.rs`
    *   **Azione:** Quando un nuovo task viene creato, inizializzare `is_paused` a `false`, `previous_state` a `None` e `subtask_uids` come un `Vec` vuoto nella `TaskStatus` e `Task` struct rispettivamente.
2.  **Modifica `Task::load` e `Project::load_task`:**
    *   **File:** `src/task.rs`, `src/project.rs`
    *   **Azione:** Aggiornare la logica di caricamento per leggere e deserializzare correttamente il nuovo campo `subtask_uids` e i campi `is_paused`, `previous_state` da `status.json` e `config.json` (se `subtask_uids` viene salvato lì, altrimenti da un nuovo file `subtasks.json` o direttamente nella `Task` struct se non persistente).
        *   **Decisione:** Per semplicità iniziale, `subtask_uids` verrà persistito all'interno di `config.json` o `status.json` del task. Optiamo per `status.json` in quanto è più legato allo stato dinamico del task.

### Fase 3: Implementazione della Logica di Gestione dei Subtask

**Obiettivo:** Aggiungere le API e la logica interna per la gestione dei subtask.

1.  **Implementazione `Task::spawn_subtask`:**
    *   **File:** `src/task.rs` (o un nuovo trait/impl se si preferisce)
    *   **Azione:** Creare un metodo `spawn_subtask(&mut self, subtask_uid: String) -> Result<(), ProjectError>` che:
        *   Aggiunge `subtask_uid` a `self.subtask_uids`.
        *   Se `self.status.is_paused` è `false`:
            *   Imposta `self.status.previous_state = Some(self.status.current_state)`.
            *   Imposta `self.status.is_paused = true`.
        *   Persiste le modifiche allo stato del task genitore (`status.json`).
2.  **Implementazione Logica Interna `subtask_completed`:**
    *   **File:** `src/task.rs` (o un modulo di gestione eventi)
    *   **Azione:** Creare una funzione (o logica all'interno di un gestore eventi) che viene invocata quando un subtask completa con successo. Questa logica dovrà:
        *   Rimuovere l'UID del subtask completato da `self.subtask_uids` del task genitore.
        *   Se `self.subtask_uids` è ora vuoto (tutti i subtask completati):
            *   Imposta `self.status.is_paused = false`.
            *   Ripristina `self.status.current_state` da `self.status.previous_state`.
        *   Persiste le modifiche allo stato del task genitore (`status.json`).
3.  **Implementazione Logica Interna `subtask_failed`:**
    *   **File:** `src/task.rs` (o un modulo di gestione eventi)
    *   **Azione:** Creare una funzione (o logica all'interno di un gestore eventi) che viene invocata quando un subtask fallisce. Questa logica dovrà:
        *   Impostare `self.status.current_state = TaskState::Failed` per il task genitore.
        *   Impostare `self.status.is_paused = false`.
        *   Persistere le modifiche allo stato del task genitore (`status.json`).
4.  **Aggiornamento `utils::update_task_status`:**
    *   **File:** `src/utils.rs`
    *   **Azione:** Modificare la funzione `update_task_status` per assicurarsi che gestisca correttamente `is_paused` e `previous_state` durante le transizioni di stato, specialmente quando un task è in pausa per subtask. Assicurarsi che non sovrascriva `previous_state` se `is_paused` è `true` a meno che non sia una transizione di fallimento.

### Fase 4: Revisione e Adattamento delle Transizioni di Stato e API Esistenti

**Obiettivo:** Adattare le funzioni esistenti per allinearsi al nuovo design e alle nuove API.

1.  **Modifica `Task::define_objective` e `Task::define_plan`:**
    *   **File:** `src/task.rs`
    *   **Azione:** Assicurarsi che queste funzioni non alterino `is_paused` o `previous_state` se il task è già in pausa per subtask.
2.  **Modifica `Task::update`:**
    *   **File:** `src/task.rs`
    *   **Azione:** Assicurarsi che questa funzione non alteri `is_paused` o `previous_state`.
3.  **Modifica `Task::review_task`:**
    *   **File:** `src/project.rs`, `src/task.rs`
    *   **Azione:** Rimuovere qualsiasi logica relativa allo stato `Replanned`. Un task `COMPLETED` rimane tale.
4.  **Implementazione `Task::error` e `Task::failure`:**
    *   **File:** `src/task.rs` (o un trait/impl)
    *   **Azione:** Creare due metodi distinti `error(&mut self, details: String) -> Result<(), ProjectError>` e `failure(&mut self, details: String) -> Result<(), ProjectError>` che aggiornano `current_state` a `TaskState::Error` o `TaskState::Failed` rispettivamente, e persistono lo stato.
5.  **Aggiornamento `TaskState::can_transition_to` (se presente):**
    *   **File:** `src/task.rs`
    *   **Azione:** Rimuovere le logiche di transizione per gli stati `Delegating`, `Harvesting`, `Replanned`.

### Fase 5: Test e Validazione

**Obiettivo:** Verificare che tutte le modifiche funzionino come previsto e che il sistema sia stabile.

1.  **Compilazione:** Eseguire una compilazione completa del progetto (`cargo build`).
2.  **Test Unitari:** Se esistono, eseguire i test unitari esistenti. Creare nuovi test unitari per la logica di `spawn_subtask` e per le reazioni interne al completamento/fallimento dei subtask.
3.  **Test di Integrazione/Manuali:**
    *   Creare un task, definirne l'obiettivo e il piano.
    *   Simulare la generazione di subtask e verificare che il task genitore vada in `is_paused = true`.
    *   Simulare il completamento di tutti i subtask con successo e verificare che il task genitore riprenda lo stato precedente (`is_paused = false`).
    *   Simulare il fallimento di un subtask e verificare che il task genitore transiti a `FAILED`.
    *   Verificare il corretto funzionamento delle nuove API `error()` e `failure()`.
    *   Verificare che le API esistenti (`define_objective`, `define_plan`, `work_completed`, ecc.) funzionino correttamente con la nuova logica di pausa.

## 3. Considerazioni Aggiuntive

*   **Persistenza di `subtask_uids`:** Assicurarsi che il `Vec<String>` di `subtask_uids` sia correttamente serializzato e deserializzato insieme allo stato del task (es. in `status.json`).
*   **Meccanismo di Notifica Subtask:** Il piano assume che esista un meccanismo (es. un gestore eventi, un sistema di polling) che notifichi il task genitore del completamento o del fallimento dei suoi subtask. Questo meccanismo dovrà essere implementato separatamente o integrato con le funzioni di reazione interna.

Questo piano fornisce una roadmap dettagliata per il refactoring. Attendo la tua approvazione per procedere.
