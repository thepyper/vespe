@include rules
@include project
@include provider/gemini_25_pro_yolo
@include agent/coder

C'e' un po di complessita' che mi sta scoppiando in mano, vorrei sistemare.
Guarda in src/execute2/state.rs, ci sono diversi stati ma c'e' molta ripetizione.
Vengono usati in src/execute2/execute.rs, leggi anche li.
Vorrei sistemare, in modo da risolvere le seguenti:

Prima idea:

C'e' parte di State che e' comune a tutti, vorrei separare le strutture in parte fissa (.status attualmente, ma aggiungero' altre cose) e parte dipendente dal tipo di State (i campi vari di AnswerState, DeriveState, etc...); per questo mi viene in mente una enum tipo:

enum State
{
    AnswerState{ common: CommonState, ... i campi particolari di AnswerState ....}
}

struct CommonState
{
    status: AnchorStatus,
}

Seconda idea, piu raffinata:

In realta' State e' un po strano perche' in parte e' particolare, in parte e' generale, e non so come risolvere questa tensione.
Attualmente ho risolto gestendo uno Status comune a tutti (che in realta' e' quasi ok, ma non esattamente aderente per tutti),
ed il resto dei campi dettagliato per ogni diverso State, e output letto usando un metodo.
Un po una porcheria.

Devo gestire i seguenti tipi di "flusso":

1) flusso A: (answer, derive, decide, inline (che in realta' non ha llm query ma read-file))
    - JustCreated -> anchor vuota, solo inserita in testo (passaggio tag-independent)
    - NeedRepeat -> anchor sporca, da svuotare per tornare a JustCreated (vuota e pulita) (passaggio tag-indepentent)
    - NeedProcessing -> anchor ha raccolto il context da processare, e deve processarlo (passaggio molto tag-dependent) 
    - NeedInjection -> anchor ha a disposizione del text da iniettare nel context (tag-indepentent)
    - Complete -> anchor completata ed inattiva

2) flusso B: (repeat)
    - JustCreated -> anchor vuota, solo inserita in testo  
    - NeedInjection -> anchor ha a disposizione del text da iniettare nel context, ovvero alterare la anchor contenente
    - Complete -> anchor completata ed inattiva

3) flusso C: (include, set)
    senza anchor, flusso basato solo sul tag senza modifiche al context di nessun tipo,
    solo comportamenti particolari del tag.

Come questo puo' essere gestito da State?

Terza idea, stellare:

In realta' poi l'ideale sarebbe una architettura in cui io non scrivo una porcheria come in execute.rs attuale,
in cui il flusso di un tag e' spezzettato in mille punti, ma vorrei avere uno (o piu') trait per i tag, che poi
vanno completati per implementare i tag.

Mi sembra moooooolta roba da digerire, chissa se ce la fai?

Se riesci, ragiona per step, e fammi una proposta di refactoring seria per ottenere un codice scritto meglio
di come e' fatto ora. Parlo di ergonomia di scrittura, di avere facilita' di aggiunta di nuovi tag,
di separazione dell'engine dai dettagli dei tag.
La funzionalita' in realta' mi va benissimo come e' fatta, con gli step fatti cosi, eccetera.

Non eseguire niente, pianifica solamente ed esponimi con massima chiarezza e dettaglio il piano.

@answer


