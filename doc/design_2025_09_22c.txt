# Design - Gestione dei Task

## Obiettivo
Definire la struttura, il ciclo di vita e le interazioni per la gestione dei task all'interno del progetto Vespe, utilizzando il filesystem come base per la persistenza dello stato.

## Concetti Fondamentali

### Task
Un task rappresenta un'unità di lavoro discreta con un obiettivo specifico.

### Subtask
Un task può essere scomposto in uno o più subtask. La relazione tra task e subtask è gerarchica e si riflette nella struttura del filesystem.
La gerarchia logica tra task e subtask sarà derivata dai metadati (es. `parent_uid` e dipendenze), non direttamente dalla struttura delle directory.

## Struttura del Task (Filesystem-based)

Ogni task (e subtask) sarà rappresentato da una directory dedicata, il cui nome sarà l'UID univoco del task. All'interno di questa directory, i file conterranno i metadati e i contenuti relativi al task. La struttura del filesystem sarà flat, con tutte le directory dei task direttamente sotto `.vespe/tasks/`.

Esempio di struttura:

```
.vespe/tasks/
├── tsk-abc123def456/             // Corrisponde a "task_001_implement_feature_X"
│   ├── config.json             // Metadati immutabili (include nome leggibile, parent_uid)
│   ├── objective.md            // Obiettivo (mutabile)
│   ├── plan.md                 // Piano di esecuzione
│   ├── status.json             // Stato corrente del task
│   ├── persistent/             // Storia interna del task (log, decisioni LLM, tool outputs)
│   └── result/                 // Risultati finali e consumabili del task
│   └── dependencies.json       // Dipendenze da altri task
├── tsk-xyz789uvw012/             // Corrisponde a "subtask_001_design_api"
│   ├── config.json
│   ├── objective.md
│   └── status.json
└── tsk-pqr012stu345/             // Corrisponde a "task_002_fix_bug_Y"
    ├── config.json
    └── ...
```

### Rationale per la Struttura Flat con UID
La scelta di una struttura flat con directory nominate tramite UID è motivata dalla necessità di robustezza e gestibilità programmatica. Questo approccio disaccoppia la rappresentazione logica (gerarchia, nomi leggibili) dalla rappresentazione fisica sul filesystem.
*   **Pro:** Robustezza a ridenominazioni e spostamenti (solo aggiornamenti di metadati), unicità garantita dei nomi delle directory, semplificazione delle operazioni sul filesystem, disaccoppiamento tra storage e presentazione.
*   **Contro:** Scarsa leggibilità diretta del filesystem per l'utente; richiede l'uso della CLI/API di Vespe per una navigazione significativa. Questo tradeoff è accettabile in quanto la cartella `.vespe` è intesa come un'area di lavoro interna gestita dal sistema.

### File e Cartelle di Configurazione del Task

1.  **`config.json` (Immutabile)**:
    *   `uid`: Stringa univoca per identificare il task (essenziale per referenziare dipendenze e per l'integrità del sistema).
    *   `name`: Nome leggibile del task.
    *   `created_by`: Utente o agente che ha creato il task.
    *   `created_at`: Timestamp di creazione.
    *   `parent_uid`: (Opzionale) UID del task genitore, se è un subtask.

    ```json
    {
      "uid": "tsk-abc123def456",
      "name": "Implementazione Autenticazione Utente",
      "created_by": "user_cli",
      "created_at": "2025-09-22T10:00:00Z",
      "parent_uid": null
    }
    ```

2.  **`objective.md` (Mutabile)**:
    *   Contiene la descrizione dettagliata dell'obiettivo del task. Può essere modificato nel tempo.

3.  **`plan.md` (Mutabile)**:
    *   Descrive i passi necessari per raggiungere l'obiettivo. Può essere generato dall'utente, da un LLM o da una combinazione.
    *   Potrebbe includere sezioni per domande all'utente o note.

4.  **`status.json` (Mutabile)**:
    *   `current_state`: Stato attuale del task (vedi "Ciclo di Vita del Task").
    *   `last_updated_at`: Timestamp dell'ultimo aggiornamento di stato.
    *   `progress`: (Opzionale) Percentuale di completamento o descrizione del progresso.
    *   `parent_content_hashes`: (Opzionale) Mappa degli hash dei contenuti dei task dipendenti, registrati al momento del completamento della dipendenza. Usato per rilevare modifiche a monte.

    ```json
    {
      "current_state": "created",
      "last_updated_at": "2025-09-22T10:00:00Z",
      "progress": "0%",
      "parent_content_hashes": {
        "tsk-xyz789uvw012_objective": "sha256-abcdef12345..."
      }
    }
    ```

5.  **`dependencies.json` (Opzionale, Mutabile)**:
    *   Un array di UID di task da cui questo task dipende.

    ```json
    {
      "depends_on": ["tsk-xyz789uvw012"]
    }
    ```

6.  **`persistent/` (Cartella per la Storia Interna):**
    *   Contiene file generati dagli agenti (nominati con timestamp, es. `YYYYMMDDhhmmss_ms_event.json`) che registrano la storia interna del task: prompt LLM, risposte LLM, chiamate a tool, output di tool, decisioni prese.
    *   Questa storia è destinata principalmente all'LLM per mantenere il contesto e per scopi di debugging/audit.
    *   Non è destinata al consumo diretto da parte di altri task o utenti finali.

7.  **`result/` (Cartella per i Risultati Consumabili):**
    *   Contiene i risultati finali e consumabili prodotti dal task.
    *   Il contenuto è specifico per il task (es. codice generato, documentazione, dati, report).
    *   Può essere popolata in modo incrementale durante l'esecuzione del task.
    *   È la cartella da cui altri task o utenti leggeranno l'output di un task completato.
    *   I nomi dei file dovrebbero essere descrittivi del loro contenuto (es. `generated_code.rs`, `api_spec.json`).

## Fasi Predefinite del Task (Subtask Hard-wired)

Per formalizzare il workflow di un task, alcune fasi cruciali possono essere trattate come subtask "hard-wired" o predefiniti. Questi subtask avranno dipendenze implicite o esplicite:

*   **`define_objective`**: Subtask per la definizione dell'obiettivo principale del task.
*   **`create_plan`**: Subtask per la creazione del piano di esecuzione, dipendente da `define_objective`.
*   **`create_subtasks`**: Subtask per la scomposizione del task in ulteriori subtask, dipendente da `create_plan`.

Questa struttura permette una gestione granulare del processo di pianificazione e una chiara definizione delle dipendenze tra le fasi.

## Ciclo di Vita del Task (Stati)

I task possono transitare tra i seguenti stati:

*   **`created`**: Il task è stato definito, ma non è ancora iniziato.
*   **`planning`**: Il task è in fase di pianificazione (es. l'LLM sta elaborando un piano o chiedendo chiarimenti).
*   **`ready`**: Il task ha un piano e tutte le sue dipendenze sono soddisfatte, pronto per essere avviato.
*   **`started`**: L'esecuzione del task è iniziata.
*   **`paused`**: L'esecuzione del task è temporaneamente sospesa.
*   **`blocked`**: Il task è bloccato, in attesa di un'azione esterna o di una risoluzione di un problema.
*   **`changed`**: Il task è stato modificato (obiettivo, piano, ecc.) o una delle sue dipendenze a monte è cambiata (rilevato tramite hash mismatch). Richiede una ri-valutazione o ri-pianificazione.
*   **`done`**: Il task è stato completato con successo.
*   **`failed`**: Il task non è riuscito a completarsi a causa di un errore.
*   **`aborted`**: Il task è stato interrotto dall'utente o dal sistema prima del completamento.

## Relazioni e Dipendenze

*   **Gerarchia Logica**: La gerarchia tra task e subtask è definita dai metadati (es. `parent_uid` in `config.json`) e dal grafo delle dipendenze, non dalla struttura fisica delle directory.
*   **Dipendenze Esplicite**: Le dipendenze tra task sono esplicitate in `dependencies.json`. Queste sono l'unico criterio di ordinazione forzato. Un task non può passare allo stato `ready` o `started` se le sue dipendenze non sono `done` o `aborted` (a seconda della politica).
*   **Invalidazione Basata su Hash (Makefile-like)**:
    *   Quando un task dipendente viene completato (o passa allo stato `ready`), registra nel proprio `status.json` l'hash del contenuto rilevante (es. `objective.md`, `plan.md`, o un hash combinato dei risultati in `result/`) del task da cui dipende.
    *   Periodicamente, o al tentativo di avviare un task, il sistema confronterà l'hash memorizzato con l'hash corrente del contenuto del task dipendente.
    *   Se gli hash non corrispondono, significa che il contenuto del task a monte è cambiato. In questo caso, il task dipendente transiterà automaticamente allo stato `changed`, richiedendo una rivalutazione o ri-pianificazione.
*   **Esecuzione**: I task senza dipendenze o con dipendenze soddisfatte e non nello stato `changed` possono essere eseguiti in parallelo o in qualsiasi ordine.

## Interazioni

*   **Creazione**: Un task può essere creato manualmente o tramite un comando CLI/API.
*   **Pianificazione**: La creazione del `plan.md` può essere assistita da un LLM, che può anche porre domande all'utente per affinare il piano.
*   **Progressione**: Gli stati del task vengono aggiornati in base all'avanzamento.
*   **Modifica**: L'obiettivo o il piano possono essere modificati, portando il task allo stato `changed`.
*   **Rivalutazione**: I task nello stato `changed` richiederanno un intervento (manuale o LLM) per essere riportati a uno stato `ready` o per essere ri-pianificati.