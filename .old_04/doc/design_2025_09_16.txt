# Design Document: Progetto "Vespe" - Sistema Multi-Agente Autonomo

**Data:** 16 Settembre 2025
**Autore:** Gemini CLI Agent

## 1. Visione Generale del Sistema

Il progetto "Vespe" mira a creare un sistema multi-agente autonomo, ispirato all'interazione con un'interfaccia a riga di comando (CLI) come Gemini-CLI, ma con la capacità di definire agenti e task in modo flessibile tramite file. L'obiettivo è permettere agli utenti di specificare ruoli, personalità, interazioni e gerarchie degli agenti, nonché definire missioni complesse, il tutto con una gestione robusta del contesto e della memoria. Il sistema sarà distribuito come un singolo eseguibile, preferibilmente in Rust, per semplicità di distribuzione e prestazioni.

## 2. Definizione di Agenti e Task

La flessibilità nella definizione degli agenti e dei task è un requisito fondamentale.

### 2.1. Definizione degli Agenti
*   **Formato:** Si utilizzeranno formati strutturati come **JSON o YAML** per le definizioni principali degli agenti. Questo garantisce leggibilità dalla macchina, facilità di parsing e validazione.
    *   **Campi Esempi:** `name`, `role`, `goals`, `tools_available`, `communication_channels`, `hierarchy_level`.
*   **Personalità e Istruzioni Dettagliate:** Per aspetti più sfumati come la personalità o istruzioni comportamentali complesse, si potrà includere un campo di **testo libero** all'interno della struttura JSON/YAML (es. `personality_description: "Sono un agente proattivo e orientato al problem-solving..."`).
*   **Schema e Validazione:** Per garantire coerenza e prevenire errori, si potrà definire uno schema (es. JSON Schema) per le definizioni degli agenti.
*   **Modularità:** Ogni definizione di agente dovrebbe idealmente risiedere in un file separato o in una sezione chiaramente delimitata per facilitare la gestione e la riusabilità.

### 2.2. Definizione dei Task/Missioni
*   **Formato:** Anche per i task, **JSON o YAML** saranno i formati preferiti per definire parametri, dipendenze, criteri di successo e l'obiettivo generale.
    *   **Campi Esempi:** `task_id`, `description`, `agent_assigned`, `dependencies`, `success_criteria`, `input_parameters`, `output_format`.
*   **Descrizione del Problema:** Il testo libero sarà utilizzato per la descrizione dettagliata del problema o dell'obiettivo della missione.
*   **Workflow/Task Graph:** Per missioni complesse, sarà cruciale definire un grafo di task che specifichi dipendenze, esecuzione parallela e sequenziale.

## 3. Architettura del Sistema Multi-Agente Autonomo

Il sistema "Vespe" sarà composto da diversi elementi chiave per garantire autonomia e coordinamento.

*   **Orchestratore Centrale ("Grand-Manager"):** Questo componente sarà il cervello del sistema. Le sue responsabilità includeranno:
    *   Caricamento e interpretazione delle definizioni di agenti e task.
    *   Istanziazione e gestione del ciclo di vita degli agenti.
    *   Assegnazione dei task agli agenti appropriati.
    *   Gestione della comunicazione e del coordinamento tra gli agenti.
    *   Interazione con i sistemi di memoria per il recupero e l'archiviazione del contesto.
    *   Monitoraggio del progresso delle missioni e gestione degli errori.
    *   Fornire un'interfaccia per l'interazione con l'utente.
*   **Agenti:** Entità autonome che eseguono task specifici in base al loro ruolo e alle loro capacità. Ogni agente interagirà con l'LLM e utilizzerà gli strumenti a sua disposizione.
*   **Protocollo di Comunicazione:** Un meccanismo chiaro per lo scambio di informazioni tra gli agenti (es. message passing, una "bacheca" condivisa, API interne).
*   **Registro Strumenti (Tool Registry):** Un sistema che permette agli agenti di scoprire e utilizzare dinamicamente gli strumenti disponibili (es. accesso al filesystem, web search, esecuzione di codice, interazione con API esterne).
*   **Feedback Loops:** Meccanismi per permettere agli agenti di fornire feedback, imparare dai fallimenti e affinare le proprie strategie nel tempo.
*   **Monitoraggio e Logging:** Essenziale per comprendere il comportamento degli agenti, debuggare problemi e analizzare le prestazioni.

## 4. Gestione del Contesto e Memoria Non Volatile

La gestione della memoria è cruciale per superare la natura stateless degli LLM e garantire un comportamento coerente e informato.

*   **Natura Stateless degli LLM:** È fondamentale ricordare che gli LLM non hanno memoria intrinseca tra le chiamate API. Tutta la "memoria" deve essere gestita esternamente dal sistema "Vespe".
*   **Approccio a Memoria a Strati:** Si adotterà un approccio stratificato per la memoria, utilizzando diversi strumenti per diversi tipi di informazioni:

    1.  **Memoria a Breve Termine (Contesto del Prompt):**
        *   **Scopo:** Mantenere il contesto immediato della conversazione o del task corrente.
        *   **Implementazione:** La storia recente della conversazione, lo stato attuale dell'agente e le istruzioni specifiche vengono inclusi direttamente nel prompt inviato all'LLM.
        *   **Limitazioni:** Vincolata dalla finestra di contesto dell'LLM e dai costi.

    2.  **Memoria a Lungo Termine (Non Volatile):**
        *   **File System (Testo, JSON, YAML):**
            *   **Uso:** Ideale per configurazioni statiche (definizioni di agenti/task), log di attività, o dati temporanei di piccole dimensioni.
            *   **Vantaggi:** Semplicità, leggibilità umana.
            *   **Svantaggi:** Difficile da interrogare in modo efficiente per grandi volumi di dati dinamici.
        *   **Database Strutturati (SQL/NoSQL):**
            *   **Uso:** Archiviazione di dati strutturati come la cronologia dettagliata delle interazioni, lo stato interno degli agenti, fatti appresi in formato chiave-valore, risultati di tool.
            *   **Vantaggi:** Interrogazioni efficienti, scalabilità, integrità dei dati.
            *   **Esempi:** SQLite (per database locali e embedded), PostgreSQL, MongoDB.
        *   **Database Vettoriali (Vector Databases):**
            *   **Uso:** Fondamentale per la "memoria semantica". Le informazioni (testo, osservazioni, fatti) vengono convertite in "embeddings" (rappresentazioni numeriche del significato) e archiviate. Permettono il recupero di informazioni *semanticamente simili* a una query. Cruciale per la **Retrieval Augmented Generation (RAG)**.
            *   **Vantaggi:** Recupero contestuale avanzato, scalabilità per grandi basi di conoscenza.
            *   **Esempi:** Pinecone, Weaviate, Milvus, Chroma, Qdrant (o implementazioni locali basate su librerie come `faiss`).

*   **Best Practice per la Memoria:**
    *   **Strategia di Recupero:** Definire come l'agente accederà alla memoria (ricerca per parole chiave, ricerca semantica, query strutturate).
    *   **Gestione della Memoria:** Implementare politiche per la pulizia, la riassunzione o l'archiviazione delle informazioni obsolete.
    *   **Prompt Engineering per la Memoria:** Progettare prompt che integrino efficacemente le informazioni recuperate dalla memoria senza sovraccaricare l'LLM.

## 5. Struttura del Progetto e Configurazione

Per garantire modularità, portabilità e facilità di gestione.

### 5.1. Cartella `.vespe` per Contesto di Progetto
*   **Posizione:** Una cartella `.vespe/` sarà creata nella radice di ogni progetto Git in cui le "Vespe" opereranno.
*   **Contenuto:** Conterrà tutte le configurazioni, i dati e la memoria specifici per quel progetto.
    *   `./vespe/agents/`: Definizioni JSON/YAML degli agenti specifici del progetto.
    *   `./vespe/tasks/`: Definizioni JSON/YAML dei task/missioni specifiche del progetto.
    *   `./vespe/memory/`: File di database (es. SQLite), file di database vettoriali locali, o file di testo per la memoria locale.
    *   `./vespe/logs/`: Log delle attività delle "Vespe" per questo progetto.
    *   `./vespe/config.json/yaml`: Override di configurazione specifici per il progetto.
*   **`.gitignore`:** La cartella `.vespe/` (o almeno i suoi contenuti dinamici) sarà aggiunta al `.gitignore` per evitare di commettere dati non necessari nel repository Git.
*   **Portabilità:** Tutti i percorsi all'interno di `.vespe/` saranno relativi alla radice del progetto.

### 5.2. Configurazione Globale del Sistema
*   **Scopo:** Contiene impostazioni a livello di sistema che non sono specifiche di un singolo progetto.
*   **Contenuto:**
    *   Chiavi API per servizi esterni (LLM, cloud, ecc.) - **gestite tramite variabili d'ambiente o un gestore di segreti, non direttamente nel file.**
    *   Modelli LLM predefiniti.
    *   Personalità e istruzioni per l'Orchestratore ("Grand-Manager").
    *   Impostazioni di logging globali.
    *   Template di agenti generici riutilizzabili.
*   **Posizione:**
    *   **Utente:** `~/.config/vespe/config.json` (Linux/macOS) o `%APPDATA%\vespe\config.json` (Windows) per personalizzazioni utente.
    *   **Sistema:** `/etc/vespe/config.json` (Linux) o nella directory di installazione (Windows) per i default a livello di sistema.
*   **Gerarchia:** La configurazione globale fornirà i valori di default, che potranno essere sovrascritti dalla configurazione specifica del progetto.

## 6. Implementazione come Singolo Eseguibile (Rust)

*   **Scelta di Rust:** Rust è la scelta preferita per la sua capacità di compilare in un singolo eseguibile statico, le sue prestazioni e la sicurezza della memoria.
*   **Vantaggi:** Semplifica la distribuzione, riduce le dipendenze esterne e offre un'esperienza utente fluida.
*   **Modularità Interna:** Anche se un singolo eseguibile, il codice Rust sarà altamente modulare, con chiara separazione tra i componenti (agenti, orchestratore, memoria, strumenti, configurazione).
*   **Caricamento Configurazione:** L'eseguibile caricherà prima la configurazione globale, poi cercherà la cartella `.vespe/` nel progetto corrente e caricherà la configurazione specifica del progetto per applicare gli override.

Questo documento servirà come base per lo sviluppo del sistema "Vespe", guidando le decisioni architetturali e implementative.
