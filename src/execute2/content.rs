use serde::{
    de::{self, SeqAccess, Visitor},
    Deserialize, Deserializer, Serialize,
};
use std::fmt;

/// Represents content originating from the system.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemModelContent {
    text: String,
}

/// Represents content originating from the user's prompt or context files.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserModelContent {
    text: String,
}

/// Represents content generated by an agent or a previous model turn.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentModelContent {
    author: String,
    text: String,
}

/// An enum that represents a single piece of content in a conversation or prompt
/// sent to a model. It distinguishes between system instructions, user input,
/// and agent responses.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ModelContentItem {
    System(SystemModelContent),
    User(UserModelContent),
    Agent(AgentModelContent),
}

impl ModelContentItem {
    /// A helper function to create a `User` content item.
    pub fn user(text: &str) -> Self {
        ModelContentItem::User(UserModelContent { text: text.into() })
    }
    pub fn system(text: &str) -> Self {
        ModelContentItem::System(SystemModelContent { text: text.into() })
    }
}

impl ToString for ModelContentItem {
    fn to_string(&self) -> String {
        match self {
            ModelContentItem::System(content) => format!("{}", content.text),
            ModelContentItem::User(content) => format!("{}", content.text),
            ModelContentItem::Agent(content) => format!("{}", content.text),
        }
    }
}

/// A struct representing a full conversation or a multi-part prompt.
#[derive(Debug, Clone, Serialize)]
pub struct ModelContent(pub Vec<ModelContentItem>);

impl ModelContent {
    pub fn new() -> Self {
        ModelContent(Vec::new())
    }

    pub fn push(&mut self, item: ModelContentItem) {
        self.0.push(item);
    }
}

impl Default for ModelContent {
    fn default() -> Self {
        Self::new()
    }
}

impl ToString for ModelContent {
    fn to_string(&self) -> String {
        self.0
            .iter()
            .map(|item| item.to_string())
            .collect::<Vec<String>>()
            .join("\n")
    }
}
/*
impl<'de> Deserialize<'de> for ModelContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct ModelContentVisitor;

        impl<'de> Visitor<'de> for ModelContentVisitor {
            type Value = ModelContent;

            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                formatter.write_str("a string or a sequence of model content items")
            }

            fn visit_str<E>(self, value: &str) -> Result<ModelContent, E>
            where
                E: de::Error,
            {
                Ok(ModelContent(vec![ModelContentItem::user(value)]))
            }

            fn visit_seq<A>(self, seq: A) -> Result<ModelContent, A::Error>
            where
                A: SeqAccess<'de>,
            {
                let items = Vec::<ModelContentItem>::deserialize(
                    de::value::SeqAccessDeserializer::new(seq),
                )?;
                Ok(ModelContent(items))
            }
        }

        deserializer.deserialize_any(ModelContentVisitor)
    }
}
*/