# Piano di Implementazione CLI - 2025-09-23d

## Obiettivo
Implementare una Command Line Interface (CLI) strutturata per il progetto Vespe, mappando le funzionalità esposte dalla crate `project`. I comandi principali saranno `task`, `tool`, e `project`, con relativi sottocomandi. Sarà possibile identificare task e tool sia tramite UID che tramite nome (gestendo i casi di ambiguità).

---

### Fase 0: Preparazione e Branching
1.  **Creazione Branch Git:** Creare un nuovo branch per lo sviluppo di questa funzionalità per isolare le modifiche.
    ```sh
    git checkout -b feature/cli-commands
    ```
2.  **Commit Iniziale:** Creare un commit iniziale per registrare l'inizio dei lavori sul nuovo branch.

---

### Fase 1: Ristrutturazione dei Comandi CLI
1.  **Creare `src/cli/commands.rs`:** Spostare le definizioni dei comandi `clap` da `src/bin/vespe_cli.rs` in un nuovo modulo dedicato (`src/cli/commands.rs`) per mantere il codice pulito e organizzato.
2.  **Definire la Struttura Principale:** In `src/cli/commands.rs`, definire la struttura principale con i tre sottocomandi `Task`, `Tool`, e `Project`.
    ```rust
    #[derive(Subcommand)]
    pub enum Commands {
        Task(TaskCommand),
        Tool(ToolCommand),
        Project(ProjectCommand),
    }
    ```
3.  **Spostare `init`:** Il comando `init` attuale verrà spostato sotto `project`, diventando `project init`.

---

### Fase 2: Implementazione dei Sottocomandi `task`
1.  **Aggiungere `list_all_tasks` all'API `project`:** Per poter risolvere i task per nome, è necessaria una funzione in `project/src/api.rs` che restituisca tutti i task presenti, simile a `list_available_tools`.
2.  **Logica di Risoluzione (UID/Nome):**
    *   Creare un nuovo modulo `src/cli/resolve.rs`.
    *   Implementare una funzione `resolve_task(project_root: &Path, identifier: &str) -> Result<Task, Error>` che:
        a. Prova a caricare il task usando l'identificatore come UID.
        b. Se fallisce, usa la nuova `list_all_tasks` per cercare un task con quel nome.
        c. Se trova più task con lo stesso nome, restituisce un errore di ambiguità.
        d. Se non trova nulla, restituisce un errore "not found".
3.  **Implementare i Sottocomandi `task`:**
    *   `task create --name <NAME> ...`: Chiama `project::api::create_task`.
    *   `task show <UID_OR_NAME>`: Usa la logica di risoluzione per trovare il task e poi ne stampa i dettagli.
    *   `task define-objective <UID_OR_NAME> --objective <CONTENT>`: Risolve il task e chiama `project::api::define_objective`. L'obiettivo potrà essere passato come stringa o da un file.
    *   `task define-plan <UID_OR_NAME> --plan <CONTENT>`: Simile a `define-objective`.
    *   `task list`: Elenca tutti i task (UID e nome).
4.  **Commit di Fase:** Eseguire un commit al termine dell'implementazione dei comandi `task`.

---

### Fase 3: Implementazione dei Sottocomandi `tool`
1.  **Logica di Risoluzione (UID/Nome):** Implementare `resolve_tool` in `src/cli/resolve.rs`, con una logica analoga a quella dei task.
2.  **Implementare i Sottocomandi `tool`:**
    *   `tool create --name <NAME> --description <DESC> --schema <SCHEMA_FILE>`: Chiama `project::api::create_tool`.
    *   `tool show <UID_OR_NAME>`: Usa la logica di risoluzione per mostrare i dettagli di un tool.
    *   `tool list`: Chiama `project::api::list_available_tools` e formatta l'output.
3.  **Commit di Fase:** Eseguire un commit al termine dell'implementazione dei comandi `tool`.

---

### Fase 4: Implementazione dei Sottocomandi `project`
1.  **Implementare i Sottocomandi `project`:**
    *   `project init`: Funzionalità già esistente, da integrare nella nuova struttura.
    *   `project info`: Mostra informazioni sul progetto (es. percorso root, numero di task, numero di tool).
    *   `project validate`: Esegue un controllo di consistenza sul progetto (es. verifica che tutti i file JSON siano validi). (Da implementare in `project::api`).
2.  **Commit di Fase:** Eseguire un commit al termine dell'implementazione dei comandi `project`.

---

### Fase 5: Conclusione
1.  **Test e Rifinitura:** Eseguire `cargo test` e `cargo build` per assicurarsi che tutto compili e funzioni correttamente.
2.  **Merge Branch:** Eseguire il merge del branch `feature/cli-commands` nel branch principale (es. `main` o `master`).
    ```sh
    git checkout main
    git merge feature/cli-commands
    ```
3.  **Commit Finale:** Creare un commit finale di merge.
