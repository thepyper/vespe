use serde::{
    de::{self, SeqAccess, Visitor},
    Deserialize, Deserializer, Serialize,
};
use std::fmt;

/// Represents content originating from the system.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemModelContent {
    text: String,
}

/// Represents content originating from the user's prompt or context files.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserModelContent {
    text: String,
}

/// Represents content generated by an agent or a previous model turn.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentModelContent {
    text: String,
}

/// An enum that represents a single piece of content in a conversation or prompt
/// sent to a model. It distinguishes between system instructions, user input,
/// and agent responses.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ModelContentItem {
    System(SystemModelContent),
    User(UserModelContent),
    Agent(AgentModelContent),
}

impl ModelContentItem {
    /// A helper function to create a `User` content item.
    pub fn user(text: &str) -> Self {
        ModelContentItem::User(UserModelContent { text: text.into() })
    }
    pub fn system(text: &str) -> Self {
        ModelContentItem::System(SystemModelContent { text: text.into() })
    }
    pub fn agent(text: &str) -> Self {
        ModelContentItem::Agent(AgentModelContent { text: text.into() })
    }
    pub fn to_prompt(&self) -> String {
        match self {
            ModelContentItem::System(content) => format!("---\nSystem Message:\n{}\n---\n", content.text),
            ModelContentItem::User(content) => format!("---\nUser Message:\n{}\n---\n", content.text),
            ModelContentItem::Agent(content) => format!("---\nAgent Message:\n{}\n---\n", content.text),
        }
    }
}

impl ToString for ModelContentItem {
    fn to_string(&self) -> String {
        match self {
            ModelContentItem::System(content) => format!("{}", content.text),
            ModelContentItem::User(content) => format!("{}", content.text),
            ModelContentItem::Agent(content) => format!("{}", content.text),
        }
    }
}

/// A struct representing a full conversation or a multi-part prompt.
#[derive(Debug, Clone, Serialize)]
pub struct ModelContent(pub Vec<ModelContentItem>);

impl ModelContent {
    pub fn new() -> Self {
        ModelContent(Vec::new())
    }

    pub fn extend(&mut self, content: ModelContent) {
        self.0.extend(content.0.into_iter());
    }

    pub fn push(&mut self, item: ModelContentItem) {
        self.0.push(item);
    }

    pub fn to_prompt(&self) -> String {
        self.0
            .iter()
            .map(|item| item.to_prompt())
            .collect::<Vec<String>>()
            .join("\n")
    }
}

impl Default for ModelContent {
    fn default() -> Self {
        Self::new()
    }
}

impl ToString for ModelContent {
    fn to_string(&self) -> String {
        self.0
            .iter()
            .map(|item| item.to_string())
            .collect::<Vec<String>>()
            .join("\n")
    }
}
