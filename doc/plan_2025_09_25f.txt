# Piano di Refactoring API per il Ciclo di Vita del Task

Questo piano delinea i passaggi dettagliati per migrare l'API esistente del crate `vespe` (principalmente `src/task.rs` e `src/project.rs`) al nuovo design del ciclo di vita del task definito in `doc/design_2025_09_25d.txt`.

## FASE 0: Preparazione e Definizione Nuovi Tipi

1.  **Aggiornare `vespe/src/task.rs`:**
    *   **Modificare `TaskState` enum:**
        *   Rimuovere `Created`, `ObjectiveDefined`, `PlanDefined`, `Executing`, `WaitingForSubtasks`, `NeedsReview`, `Completed`, `Failed`, `Aborted`, `Replanned`.
        *   Aggiungere i nuovi stati: `CREATED`, `OBJECTIVE_DEFINED`, `PLAN_DEFINED`, `DELEGATING`, `HARVESTING`, `WORKING`, `ERROR`, `FAILED`, `COMPLETED`.
        *   Aggiungere `#[derive(Debug, PartialEq, Eq, Clone, Copy, Serialize, Deserialize)]` all'enum.
    *   **Definire `TaskType` enum:**
        *   Aggiungere `enum TaskType { Monolithic, Subdivided }` (o `is_monolithic: bool` come campo nel plan).
    *   **Definire `SubtaskStatus` enum:**
        *   Aggiungere `enum SubtaskStatus { Completed, Failed(String), Error(String) }`.
    *   **Modificare `TaskConfig` struct:**
        *   Aggiungere `task_type: Option<TaskType>` (sarà `None` fino a `PLAN_DEFINED`).
    *   **Modificare `TaskStatus` struct:**
        *   Aggiungere `is_paused: bool`.
        *   Aggiungere `error_details: Option<String>`.
        *   Aggiungere `previous_state: Option<TaskState>` (per il recupero da `ERROR`).
        *   Aggiungere `retry_count: u8` (per `ERROR`).
    *   **Modificare `Task` struct:**
        *   Rimuovere i metodi `define_objective`, `define_plan`, `update`, `review_task`.
        *   Aggiungere un campo `subtasks: HashMap<String, SubtaskStatus>` per tenere traccia dei sub-task.

2.  **Aggiornare `vespe/src/error.rs`:**
    *   Aggiungere nuovi varianti a `ProjectError` per gestire errori specifici delle nuove transizioni di stato (es. `InvalidStateTransition`, `TaskNotFound`, `SubtaskNotFound`).

## FASE 1: Implementazione del Trait `TaskLifecycle` su `Project`

1.  **Creare il trait `TaskLifecycle` in `vespe/src/project.rs` (o un nuovo file `vespe/src/task_manager.rs`):**
    *   Definire il trait `TaskLifecycle` esattamente come specificato nel design `doc/design_2025_09_25d.txt`.
    *   Per ora, implementeremo questo trait direttamente sulla struct `Project`. Se la logica diventa troppo complessa, potremmo estrarre un `TaskManager` separato.

2.  **Implementare `TaskLifecycle` per `Project` in `vespe/src/project.rs`:**
    *   **`define_objective(&mut self, task_id: &str, objective_content: String)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da `CREATED` o `OBJECTIVE_DEFINED` a `OBJECTIVE_DEFINED`).
        *   Aggiornare `task.objective` e salvare `objective.md`.
        *   Aggiornare `task.status.current_state` a `OBJECTIVE_DEFINED` e salvare `status.json`.
    *   **`define_plan(&mut self, task_id: &str, plan_content: String, task_type: TaskType)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da `OBJECTIVE_DEFINED` o `PLAN_DEFINED` a `PLAN_DEFINED`).
        *   Aggiornare `task.plan` e salvare `plan.md`.
        *   Aggiornare `task.config.task_type` e salvare `config.json`.
        *   Aggiornare `task.status.current_state` a `PLAN_DEFINED` e salvare `status.json`.
    *   **`accept_plan(&mut self, task_id: &str)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da `PLAN_DEFINED`).
        *   Basandosi su `task.config.task_type`:
            *   Se `Monolithic` -> Aggiornare `task.status.current_state` a `WORKING`.
            *   Se `Subdivided` -> Aggiornare `task.status.current_state` a `DELEGATING`.
        *   Salvare `status.json`.
    *   **`reject_plan(&mut self, task_id: &str)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da `PLAN_DEFINED`).
        *   Aggiornare `task.status.current_state` a `OBJECTIVE_DEFINED`.
        *   Salvare `status.json`.
    *   **`add_subtask(&mut self, task_id: &str, subtask_id: &str, is_final: bool)`:**
        *   Caricare il task genitore.
        *   Validare la transizione di stato (da `DELEGATING`).
        *   Aggiungere `subtask_id` alla mappa `task.subtasks` con stato iniziale (es. `CREATED`).
        *   Se `is_final == true` -> Aggiornare `task.status.current_state` a `HARVESTING`.
        *   Salvare `config.json` (se `subtasks` è parte di `config`) e `status.json`.
    *   **`error(&mut self, task_id: &str, details: String, is_failure: bool)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da qualsiasi stato tranne `FAILED`, `COMPLETED`).
        *   Salvare `task.status.previous_state` prima di cambiare stato.
        *   Se `is_failure == true` -> Aggiornare `task.status.current_state` a `FAILED`.
        *   Se `is_failure == false` -> Aggiornare `task.status.current_state` a `ERROR`.
        *   Aggiornare `task.status.error_details`.
        *   Salvare `status.json`.
    *   **`work_completed(&mut self, task_id: &str)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da `WORKING`).
        *   Aggiornare `task.status.current_state` a `COMPLETED`.
        *   Salvare `status.json`.
    *   **`abort(&mut self, task_id: &str, reason: String)`:**
        *   Caricare il task.
        *   Validare la transizione di stato (da qualsiasi stato tranne `FAILED`, `COMPLETED`).
        *   Aggiornare `task.status.current_state` a `FAILED`.
        *   Aggiornare `task.status.error_details` con la ragione dell'aborto.
        *   **Implementare aborto a cascata:** Identificare e chiamare `abort()` su tutti i sub-task attivi.
        *   Salvare `status.json`.
    *   **`pause_task(&mut self, task_id: &str, reason: String)`:**
        *   Caricare il task.
        *   Impostare `task.status.is_paused = true`.
        *   Salvare `status.json`.
    *   **`resume_task(&mut self, task_id: &str)`:**
        *   Caricare il task.
        *   Impostare `task.status.is_paused = false`.
        *   Salvare `status.json`.
    *   **`get_task_state(&self, task_id: &str)`:**
        *   Caricare il task e restituire `task.status.current_state`.
    *   **`is_task_paused(&self, task_id: &str)`:**
        *   Caricare il task e restituire `task.status.is_paused`.
    *   **`subtask_terminated(&mut self, parent_task_id: &str, subtask_id: &str, status: SubtaskStatus)`:**
        *   Caricare il task genitore.
        *   Aggiornare lo stato del `subtask_id` nella mappa `task.subtasks`.
        *   **Valutare lo stato del genitore:**
            *   Se tutti i sub-task sono `COMPLETED` -> Transizione del genitore a `COMPLETED`.
            *   Se un sub-task è `FAILED` o `ERROR` -> Transizione del genitore a `ERROR` o `FAILED` (usando l'API `error()` interna).
        *   Salvare `status.json` e `config.json` (se `subtasks` è parte di `config`).

## FASE 2: Aggiornamento delle Funzioni Esistenti in `Project`

1.  **Modificare `Project::create_task`:**
    *   La funzione creerà il task nello stato `CREATED`.
    *   Non imposterà più `objective.md` vuoto, ma lo lascerà alla `define_objective`.
2.  **Rimuovere `Project::define_objective`:** La logica sarà gestita dal trait `TaskLifecycle`.
3.  **Rimuovere `Project::define_plan`:** La logica sarà gestita dal trait `TaskLifecycle`.
4.  **Rimuovere `Project::update_task`:** La logica sarà gestita dal trait `TaskLifecycle` (tramite `define_objective` e `define_plan`).
5.  **Rimuovere `Project::create_and_define_task`:** La logica sarà gestita da `create_task` seguito da `define_objective`.

## FASE 3: Aggiornamento dell'Interfaccia Utente (vespe-tui)

1.  **Modificare `vespe-tui/src/pages/task_edit.rs`:**
    *   Aggiornare le chiamate API per `F5` (Cancel) e `F6` (Save) per usare i nuovi metodi del trait `TaskLifecycle` su `app.project`.
    *   La logica di creazione/aggiornamento dovrà essere adattata per chiamare `define_objective` e `define_plan` separatamente.
    *   La logica di `abort` dovrà usare la nuova API `abort()`.

2.  **Modificare `vespe-tui/src/pages/tasks.rs`:**
    *   Aggiornare le chiamate API per la creazione di nuovi task (F5) per usare `Project::create_task` e poi `define_objective`.
    *   Aggiornare le chiamate API per l'ispezione/modifica di task esistenti (F6).

## FASE 4: Pulizia e Test

1.  **Rimuovere codice obsoleto:** Eliminare tutte le vecchie funzioni e i campi non più utilizzati.
2.  **Eseguire `cargo check` e `cargo build`:** Verificare la compilazione.
3.  **Test manuali:** Eseguire il TUI e verificare che tutte le funzionalità di creazione, modifica, salvataggio, annullamento, ispezione e navigazione dei task funzionino come previsto.

---

**Dubbi/Considerazioni per il Piano:**

*   **`TaskState` e Dati Associati:** La proposta di arricchire l'enum `TaskState` con dati associati (es. `ERROR(details: String, previous_state: TaskState)`) è molto potente. Questo influenzerà direttamente la definizione dell'enum in `src/task.rs` e come i dati vengono salvati/caricati. Per ora, il piano si concentra sulla transizione di stato, ma l'implementazione dovrà considerare questi dati.
*   **`TaskType` Storage:** Il `task_type` (Monolithic/Subdivided) deve essere persistito. La proposta è di aggiungerlo a `TaskConfig`.
*   **`retry()` e `replan_from_error()`:** Queste API sono state rimosse dal design per ora. Il piano non le implementerà in questa fase.
*   **`abort()` Cascading:** L'implementazione dell'aborto a cascata richiederà di caricare i sub-task e chiamare `abort()` su di essi. Questo implica che `abort()` deve essere ricorsivo o iterativo.
